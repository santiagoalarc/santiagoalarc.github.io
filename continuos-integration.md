---
layout: page
title: Integración continua
permalink: /continuos-integration/
---

## Hacer que la Construcción sea Auto-Verificable
Tradicionalmente, una construcción significaba compilar, enlazar y todo lo demás necesario para que un programa se ejecutara. Un programa puede ejecutarse, pero eso no significa que haga lo correcto. Los lenguajes modernos de tipado estático pueden detectar muchos errores, pero muchos más se escapan de esa red. Esto es un problema crítico si queremos integrar con la frecuencia que exige la Integración Continua. Si los errores llegan al producto, nos enfrentamos a la abrumadora tarea de corregirlos en una base de código que cambia rápidamente. La prueba manual es demasiado lenta para hacer frente a la frecuencia de los cambios.

Frente a esto, necesitamos asegurarnos de que los errores no lleguen al producto en primer lugar. La técnica principal para lograrlo es una suite de pruebas exhaustiva, que se ejecuta antes de cada integración para eliminar tantos errores como sea posible. Las pruebas no son perfectas, por supuesto, pero pueden detectar muchos errores, los suficientes para ser útiles. Las primeras computadoras que usé realizaban una auto-verificación de memoria visible al arrancar, lo que me llevó a referirme a esto como Código Auto-Verificable.

Escribir código auto-verificable afecta el flujo de trabajo de un programador. Cualquier tarea de programación combina tanto la modificación de la funcionalidad del programa como la ampliación de la suite de pruebas para verificar este comportamiento cambiado. El trabajo de un programador no termina simplemente cuando la nueva característica funciona, sino también cuando tiene pruebas automatizadas para demostrarlo.

Durante las dos décadas transcurridas desde la primera versión de este artículo, he visto cómo los entornos de programación adoptan cada vez más la necesidad de proporcionar las herramientas para que los programadores construyan tales suites de pruebas. El mayor impulso para esto fue JUnit, originalmente escrito por Kent Beck y Erich Gamma, que tuvo un impacto notable en la comunidad Java a finales de los años 90. Esto inspiró marcos de prueba similares para otros lenguajes, a menudo denominados marcos Xunit. Estos enfatizaban una mecánica ligera y amigable para el programador que permitía al programador construir pruebas fácilmente en conjunto con el código del producto. A menudo, estas herramientas tienen algún tipo de barra de progreso gráfica que está en verde si las pruebas pasan, pero se vuelve roja si alguna falla, lo que lleva a frases como "construcción verde" o "barra roja".

La prueba de una suite de pruebas así es que debemos estar seguros de que si las pruebas están en verde, no hay errores significativos en el producto. Me gusta imaginar a un duende travieso que es capaz de hacer modificaciones simples al código del producto, como comentar líneas o invertir condicionales, pero que no puede cambiar las pruebas. Una suite de pruebas sólida nunca permitiría que el duende causara ningún daño sin que una prueba se volviera roja. Y cualquier prueba que falle es suficiente para que la construcción falle, el 99.9% en verde sigue siendo rojo.

El código auto-verificable es tan importante para la Integración Continua que es un prerrequisito necesario. A menudo, la mayor barrera para implementar la Integración Continua es la habilidad insuficiente en las pruebas.

Que el código auto-verificable y la Integración Continua estén tan ligados no es una sorpresa. La Integración Continua se desarrolló originalmente como parte de la Programación Extrema (Extreme Programming) y las pruebas siempre han sido una práctica central de la Programación Extrema. Esta prueba a menudo se realiza en forma de Desarrollo Guiado por Pruebas (Test Driven Development - TDD), una práctica que nos indica que nunca debemos escribir código nuevo a menos que corrija una prueba que hemos escrito justo antes. TDD no es esencial para la Integración Continua, ya que las pruebas se pueden escribir después del código de producción siempre que se realicen antes de la integración. Pero encuentro que, la mayoría de las veces, TDD es la mejor manera de escribir código auto-verificable.

Las pruebas actúan como una verificación automatizada de la salud de la base de código, y si bien las pruebas son el elemento clave de dicha verificación automatizada del código, muchos entornos de programación proporcionan herramientas de verificación adicionales. Los linters pueden detectar malas prácticas de programación y asegurar que el código siga el estilo de formato preferido de un equipo; los escáneres de vulnerabilidades pueden encontrar debilidades de seguridad. Los equipos deben evaluar estas herramientas para incluirlas en el proceso de verificación.

Por supuesto, no podemos contar con las pruebas para encontrarlo todo. Como se ha dicho a menudo: las pruebas no demuestran la ausencia de errores. Sin embargo, la perfección no es el único punto en el que obtenemos un beneficio de una construcción auto-verificable. Las pruebas imperfectas, ejecutadas con frecuencia, son mucho mejores que las pruebas perfectas que nunca se escriben.


## Todo el mundo envía "commits" a la línea principal cada día
La integración es, ante todo, comunicación. La integración permite a los desarrolladores informar a otros desarrolladores sobre los cambios que han realizado. La comunicación frecuente permite a las personas conocer rápidamente cómo evolucionan los cambios.

El único requisito previo para que un desarrollador haga un "commit" a la línea principal es que pueda construir correctamente su código. Esto, por supuesto, incluye pasar las pruebas de construcción. Como en cualquier ciclo de "commit", el desarrollador primero actualiza su copia de trabajo para que coincida con la línea principal, resuelve cualquier conflicto con esta, y luego construye en su máquina local. Si la construcción pasa, entonces puede subir sus cambios a la línea principal.

Si todo el mundo sube sus cambios a la línea principal con frecuencia, los desarrolladores descubren rápidamente si hay un conflicto entre dos desarrolladores. La clave para solucionar problemas rápidamente es encontrarlos rápidamente. Con los desarrolladores haciendo "commits" cada pocas horas, un conflicto puede detectarse a las pocas horas de producirse; en ese momento, no ha sucedido mucho y es fácil de resolver. Los conflictos que permanecen sin detectar durante semanas pueden ser muy difíciles de resolver.

Los conflictos en la base de código se presentan de diferentes formas. Los más fáciles de encontrar y resolver son los conflictos textuales, a menudo llamados "conflictos de fusión", cuando dos desarrolladores editan el mismo fragmento de código de diferentes maneras. Las herramientas de control de versiones los detectan fácilmente una vez que el segundo desarrollador incorpora la línea principal actualizada a su copia de trabajo. El problema más difícil son los conflictos semánticos. Si mi colega cambia el nombre de una función y yo llamo a esa función en mi código recién añadido, el sistema de control de versiones no nos puede ayudar. En un lenguaje de tipado estático, obtenemos un fallo de compilación, lo cual es bastante fácil de detectar, pero en un lenguaje dinámico no obtenemos ninguna ayuda. E incluso la compilación de tipado estático no nos ayuda cuando un colega realiza un cambio en el cuerpo de una función que yo llamo, alterando sutilmente lo que hace. Por eso es tan importante tener código auto-verificable.

Un fallo en una prueba nos alerta de que hay un conflicto entre los cambios, pero todavía tenemos que averiguar cuál es el conflicto y cómo resolverlo. Dado que solo hay unas pocas horas de cambios entre "commits", hay pocos lugares donde el problema podría estar oculto. Además, como no ha cambiado mucho, podemos usar la depuración diferencial ("Diff Debugging") para ayudarnos a encontrar el error.

Mi regla general es que cada desarrollador debería hacer un "commit" a la línea principal todos los días. En la práctica, aquellos con experiencia en Integración Continua se integran con más frecuencia. Cuanto más frecuentemente nos integramos, menos lugares tenemos que buscar errores de conflicto y más rápidamente los resolvemos.

Los "commits" frecuentes animan a los desarrolladores a dividir su trabajo en pequeños fragmentos de unas pocas horas cada uno. Esto ayuda a seguir el progreso y proporciona una sensación de avance. A menudo, al principio la gente siente que no puede hacer algo significativo en solo unas pocas horas, pero hemos descubierto que la tutoría y la práctica nos ayudan a aprender.

## Cada envío a la línea principal debe activar una construcción
Si todos los miembros del equipo integran al menos diariamente, esto debería significar que la línea principal se mantiene en un estado saludable. Sin embargo, en la práctica, las cosas aún pueden salir mal. Esto puede deberse a fallos en la disciplina, a no actualizar y construir antes de un envío, o a diferencias en el entorno entre los espacios de trabajo de los desarrolladores.

Por lo tanto, necesitamos asegurar que cada "commit" sea verificado en un entorno de referencia. La forma habitual de hacer esto es con un Servicio de Integración Continua (Servicio de CI) que monitorea la línea principal. (Ejemplos de Servicios de CI son herramientas como Jenkins, GitHub Actions, Circle CI, etc.). Cada vez que la línea principal recibe un "commit", el servicio de CI extrae el encabezado de la línea principal a un entorno de integración y realiza una construcción completa. Solo una vez que esta construcción de integración esté en verde, el desarrollador puede considerar que la integración está completa. Al asegurar que tenemos una construcción con cada envío, si obtenemos una falla, sabemos que el error se encuentra en ese último envío, lo que reduce el lugar donde tenemos que buscar para corregirlo.

Quiero recalcar aquí que, cuando usamos un Servicio de CI, solo lo usamos en la línea principal, que es la rama principal en la instancia de referencia del sistema de control de versiones. Es común usar un servicio de CI para monitorear y construir desde múltiples ramas, pero el objetivo de la integración es que todos los "commits" coexistan en una sola rama. Si bien puede ser útil usar un servicio de CI para hacer una construcción automatizada para diferentes ramas, eso no es lo mismo que la Integración Continua, y los equipos que usan Integración Continua solo necesitarán que el servicio de CI monitoree una única rama del producto.

Aunque casi todos los equipos utilizan Servicios de CI hoy en día, es perfectamente posible hacer Integración Continua sin uno. Los miembros del equipo pueden extraer manualmente el encabezado de la línea principal a una máquina de integración y realizar una construcción para verificar la integración. Pero tiene poco sentido un proceso manual cuando la automatización está tan fácilmente disponible.

(Este es un buen punto para mencionar que mis colegas en Thoughtworks han contribuido mucho con herramientas de código abierto para la Integración Continua, en particular Cruise Control, el primer Servicio de CI.)

## Solucionar las construcciones fallidas de inmediato

La Integración Continua solo puede funcionar si la línea principal se mantiene en un estado saludable. Si la construcción de integración falla, debe solucionarse de inmediato. Como dice Kent Beck: "nadie tiene una tarea de mayor prioridad que arreglar la construcción". Esto no significa que todos en el equipo tengan que dejar lo que están haciendo para arreglar la construcción; por lo general, solo se necesitan un par de personas para que las cosas vuelvan a funcionar. Sí significa una priorización consciente de una corrección de construcción como una tarea urgente y de alta prioridad.

Normalmente, la mejor manera de arreglar la construcción es revertir el último "commit" de la línea principal, llevando el sistema de vuelta a la última construcción conocida y buena. Si la causa del problema es inmediatamente obvia, entonces se puede solucionar directamente con un nuevo "commit", pero de lo contrario, revertir la línea principal permite a algunas personas averiguar el problema en un entorno de desarrollo separado, permitiendo que el resto del equipo continúe trabajando con la línea principal.

Algunos equipos prefieren eliminar todo riesgo de romper la línea principal utilizando una "Pending Head" (también llamada "Pre-tested", "Delayed" o "Gated Commit"). Para ello, el servicio de CI necesita configurar las cosas para que los "commits" enviados a la línea principal para la integración no pasen inmediatamente a la línea principal. En su lugar, se colocan en otra rama hasta que la construcción se completa y solo se migran a la línea principal después de una construcción en verde. Si bien esta técnica evita cualquier peligro de ruptura de la línea principal, un equipo efectivo rara vez debería ver una línea principal en rojo, y las pocas veces que sucede, su misma visibilidad anima a la gente a aprender cómo evitarlo.

## Mantener la construcción rápida
Todo el objetivo de la Integración Continua es proporcionar retroalimentación rápida. Nada agota más la esencia de la Integración Continua que una construcción que lleva mucho tiempo. Aquí debo admitir cierta diversión de viejo gruñón ante lo que se considera una construcción larga. La mayoría de mis colegas consideran que una construcción que lleva una hora es totalmente irrazonable. Recuerdo equipos soñando con lograr esa velocidad, y ocasionalmente todavía nos encontramos con casos en los que es muy difícil lograr que las construcciones alcancen esa velocidad.

Para la mayoría de los proyectos, sin embargo, la guía de XP de una construcción de diez minutos es perfectamente razonable. La mayoría de nuestros proyectos modernos lo logran. Vale la pena hacer un esfuerzo concentrado para que esto suceda, porque cada minuto recortado del tiempo de construcción es un minuto ahorrado para cada desarrollador cada vez que hacen un "commit". Dado que la Integración Continua exige "commits" frecuentes, esto se suma a una gran cantidad de tiempo.

Si estamos mirando un tiempo de construcción de una hora, entonces lograr una construcción más rápida puede parecer una perspectiva desalentadora. Incluso puede ser desalentador trabajar en un nuevo proyecto y pensar en cómo mantener las cosas rápidas. Para las aplicaciones empresariales, al menos, hemos descubierto que el cuello de botella habitual son las pruebas, particularmente las pruebas que involucran servicios externos como una base de datos.

Probablemente el paso más crucial es comenzar a trabajar en la configuración de un Pipeline de Despliegue. La idea detrás de un pipeline de despliegue (también conocido como pipeline de construcción o construcción por etapas) es que, de hecho, se realizan múltiples construcciones en secuencia. El "commit" a la línea principal activa la primera construcción, lo que yo llamo la construcción de "commit". La construcción de "commit" es la construcción que se necesita cuando alguien envía "commits" a la línea principal. La construcción de "commit" es la que debe hacerse rápidamente, por lo que tomará una serie de atajos que reducirán la capacidad de detectar errores. El truco consiste en equilibrar las necesidades de detección de errores y velocidad para que una buena construcción de "commit" sea lo suficientemente estable para que otras personas puedan trabajar en ella.

Una vez que la construcción de "commit" es buena, otras personas pueden trabajar en el código con confianza. Sin embargo, hay más pruebas, más lentas, que podemos comenzar a hacer. Máquinas adicionales pueden ejecutar más rutinas de prueba en la construcción que tardan más en realizarse.

Un ejemplo simple de esto es un pipeline de despliegue de dos etapas. La primera etapa haría la compilación y ejecutaría pruebas que son pruebas unitarias más localizadas con servicios lentos reemplazados por Test Doubles, como una base de datos falsa en memoria o un "stub" para un servicio externo. Dichas pruebas pueden ejecutarse muy rápido, manteniéndose dentro de la guía de los diez minutos. Sin embargo, no se encontrarán errores que involucren interacciones a mayor escala, particularmente aquellas que involucran la base de datos real. La segunda etapa de la construcción ejecuta una suite de pruebas diferente que sí accede a una base de datos real e implica un comportamiento más de extremo a extremo. Esta suite podría tardar un par de horas en ejecutarse.

En este escenario, las personas usan la primera etapa como la construcción de "commit" y la utilizan como su ciclo principal de CI. Si la construcción secundaria falla, esto puede no tener la misma calidad de "detener todo", pero el equipo sí tiene como objetivo solucionar esos errores lo más rápido posible, mientras mantiene la construcción de "commit" en funcionamiento. Dado que la construcción secundaria puede ser mucho más lenta, es posible que no se ejecute después de cada "commit". En ese caso, se ejecuta con la mayor frecuencia posible, seleccionando la última construcción buena de la etapa de "commit".

Si la construcción secundaria detecta un error, es una señal de que la construcción de "commit" podría necesitar otra prueba. En la medida de lo posible, queremos asegurarnos de que cualquier falla en una etapa posterior conduzca a nuevas pruebas en la construcción de "commit" que hubieran detectado el error, para que el error permanezca corregido en la construcción de "commit". De esta manera, las pruebas de "commit" se fortalecen cada vez que algo las pasa. Hay casos en los que no hay forma de construir una prueba de ejecución rápida que exponga el error, por lo que podemos decidir probar esa condición solo en la construcción secundaria. La mayoría de las veces, afortunadamente, podemos añadir pruebas adecuadas a la construcción de "commit".

Otra forma de acelerar las cosas es usar paralelismo y múltiples máquinas. Los entornos en la nube, en particular, permiten a los equipos lanzar fácilmente una pequeña flota de servidores para las construcciones. Siempre que las pruebas puedan ejecutarse de forma razonablemente independiente, lo que las pruebas bien escritas pueden hacer, el uso de dicha flota puede lograr tiempos de construcción muy rápidos. Dichas construcciones paralelas en la nube también pueden ser útiles para la construcción previa a la integración de un desarrollador.

Mientras consideramos el proceso de construcción más amplio, vale la pena mencionar otra categoría de automatización: la interacción con las dependencias. La mayoría del software utiliza una amplia gama de software dependiente producido por diferentes organizaciones. Los cambios en estas dependencias pueden causar fallas en el producto. Por lo tanto, un equipo debe verificar automáticamente las nuevas versiones de las dependencias e integrarlas en la construcción, esencialmente como si fueran otro miembro del equipo. Esto debe hacerse con frecuencia, generalmente al menos diariamente, dependiendo de la tasa de cambio de las dependencias. Se debe utilizar un enfoque similar con la ejecución de pruebas de contrato (Contract Tests). Si estas interacciones de dependencia se vuelven rojas, no tienen el mismo efecto de "detener la línea" que las fallas de construcción regulares, pero requieren una acción rápida por parte del equipo para investigar y solucionar.