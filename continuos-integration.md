---
layout: page
title: Integración continua
permalink: /continuos-integration/
---

## Hacer que la Construcción sea Auto-Verificable
Tradicionalmente, una construcción significaba compilar, enlazar y todo lo demás necesario para que un programa se ejecutara. Un programa puede ejecutarse, pero eso no significa que haga lo correcto. Los lenguajes modernos de tipado estático pueden detectar muchos errores, pero muchos más se escapan de esa red. Esto es un problema crítico si queremos integrar con la frecuencia que exige la Integración Continua. Si los errores llegan al producto, nos enfrentamos a la abrumadora tarea de corregirlos en una base de código que cambia rápidamente. La prueba manual es demasiado lenta para hacer frente a la frecuencia de los cambios.

Frente a esto, necesitamos asegurarnos de que los errores no lleguen al producto en primer lugar. La técnica principal para lograrlo es una suite de pruebas exhaustiva, que se ejecuta antes de cada integración para eliminar tantos errores como sea posible. Las pruebas no son perfectas, por supuesto, pero pueden detectar muchos errores, los suficientes para ser útiles. Las primeras computadoras que usé realizaban una auto-verificación de memoria visible al arrancar, lo que me llevó a referirme a esto como Código Auto-Verificable.

Escribir código auto-verificable afecta el flujo de trabajo de un programador. Cualquier tarea de programación combina tanto la modificación de la funcionalidad del programa como la ampliación de la suite de pruebas para verificar este comportamiento cambiado. El trabajo de un programador no termina simplemente cuando la nueva característica funciona, sino también cuando tiene pruebas automatizadas para demostrarlo.

Durante las dos décadas transcurridas desde la primera versión de este artículo, he visto cómo los entornos de programación adoptan cada vez más la necesidad de proporcionar las herramientas para que los programadores construyan tales suites de pruebas. El mayor impulso para esto fue JUnit, originalmente escrito por Kent Beck y Erich Gamma, que tuvo un impacto notable en la comunidad Java a finales de los años 90. Esto inspiró marcos de prueba similares para otros lenguajes, a menudo denominados marcos Xunit. Estos enfatizaban una mecánica ligera y amigable para el programador que permitía al programador construir pruebas fácilmente en conjunto con el código del producto. A menudo, estas herramientas tienen algún tipo de barra de progreso gráfica que está en verde si las pruebas pasan, pero se vuelve roja si alguna falla, lo que lleva a frases como "construcción verde" o "barra roja".

La prueba de una suite de pruebas así es que debemos estar seguros de que si las pruebas están en verde, no hay errores significativos en el producto. Me gusta imaginar a un duende travieso que es capaz de hacer modificaciones simples al código del producto, como comentar líneas o invertir condicionales, pero que no puede cambiar las pruebas. Una suite de pruebas sólida nunca permitiría que el duende causara ningún daño sin que una prueba se volviera roja. Y cualquier prueba que falle es suficiente para que la construcción falle, el 99.9% en verde sigue siendo rojo.

El código auto-verificable es tan importante para la Integración Continua que es un prerrequisito necesario. A menudo, la mayor barrera para implementar la Integración Continua es la habilidad insuficiente en las pruebas.

Que el código auto-verificable y la Integración Continua estén tan ligados no es una sorpresa. La Integración Continua se desarrolló originalmente como parte de la Programación Extrema (Extreme Programming) y las pruebas siempre han sido una práctica central de la Programación Extrema. Esta prueba a menudo se realiza en forma de Desarrollo Guiado por Pruebas (Test Driven Development - TDD), una práctica que nos indica que nunca debemos escribir código nuevo a menos que corrija una prueba que hemos escrito justo antes. TDD no es esencial para la Integración Continua, ya que las pruebas se pueden escribir después del código de producción siempre que se realicen antes de la integración. Pero encuentro que, la mayoría de las veces, TDD es la mejor manera de escribir código auto-verificable.

Las pruebas actúan como una verificación automatizada de la salud de la base de código, y si bien las pruebas son el elemento clave de dicha verificación automatizada del código, muchos entornos de programación proporcionan herramientas de verificación adicionales. Los linters pueden detectar malas prácticas de programación y asegurar que el código siga el estilo de formato preferido de un equipo; los escáneres de vulnerabilidades pueden encontrar debilidades de seguridad. Los equipos deben evaluar estas herramientas para incluirlas en el proceso de verificación.

Por supuesto, no podemos contar con las pruebas para encontrarlo todo. Como se ha dicho a menudo: las pruebas no demuestran la ausencia de errores. Sin embargo, la perfección no es el único punto en el que obtenemos un beneficio de una construcción auto-verificable. Las pruebas imperfectas, ejecutadas con frecuencia, son mucho mejores que las pruebas perfectas que nunca se escriben.


## Todo el mundo envía "commits" a la línea principal cada día
La integración es, ante todo, comunicación. La integración permite a los desarrolladores informar a otros desarrolladores sobre los cambios que han realizado. La comunicación frecuente permite a las personas conocer rápidamente cómo evolucionan los cambios.

El único requisito previo para que un desarrollador haga un "commit" a la línea principal es que pueda construir correctamente su código. Esto, por supuesto, incluye pasar las pruebas de construcción. Como en cualquier ciclo de "commit", el desarrollador primero actualiza su copia de trabajo para que coincida con la línea principal, resuelve cualquier conflicto con esta, y luego construye en su máquina local. Si la construcción pasa, entonces puede subir sus cambios a la línea principal.

Si todo el mundo sube sus cambios a la línea principal con frecuencia, los desarrolladores descubren rápidamente si hay un conflicto entre dos desarrolladores. La clave para solucionar problemas rápidamente es encontrarlos rápidamente. Con los desarrolladores haciendo "commits" cada pocas horas, un conflicto puede detectarse a las pocas horas de producirse; en ese momento, no ha sucedido mucho y es fácil de resolver. Los conflictos que permanecen sin detectar durante semanas pueden ser muy difíciles de resolver.

Los conflictos en la base de código se presentan de diferentes formas. Los más fáciles de encontrar y resolver son los conflictos textuales, a menudo llamados "conflictos de fusión", cuando dos desarrolladores editan el mismo fragmento de código de diferentes maneras. Las herramientas de control de versiones los detectan fácilmente una vez que el segundo desarrollador incorpora la línea principal actualizada a su copia de trabajo. El problema más difícil son los conflictos semánticos. Si mi colega cambia el nombre de una función y yo llamo a esa función en mi código recién añadido, el sistema de control de versiones no nos puede ayudar. En un lenguaje de tipado estático, obtenemos un fallo de compilación, lo cual es bastante fácil de detectar, pero en un lenguaje dinámico no obtenemos ninguna ayuda. E incluso la compilación de tipado estático no nos ayuda cuando un colega realiza un cambio en el cuerpo de una función que yo llamo, alterando sutilmente lo que hace. Por eso es tan importante tener código auto-verificable.

Un fallo en una prueba nos alerta de que hay un conflicto entre los cambios, pero todavía tenemos que averiguar cuál es el conflicto y cómo resolverlo. Dado que solo hay unas pocas horas de cambios entre "commits", hay pocos lugares donde el problema podría estar oculto. Además, como no ha cambiado mucho, podemos usar la depuración diferencial ("Diff Debugging") para ayudarnos a encontrar el error.

Mi regla general es que cada desarrollador debería hacer un "commit" a la línea principal todos los días. En la práctica, aquellos con experiencia en Integración Continua se integran con más frecuencia. Cuanto más frecuentemente nos integramos, menos lugares tenemos que buscar errores de conflicto y más rápidamente los resolvemos.

Los "commits" frecuentes animan a los desarrolladores a dividir su trabajo en pequeños fragmentos de unas pocas horas cada uno. Esto ayuda a seguir el progreso y proporciona una sensación de avance. A menudo, al principio la gente siente que no puede hacer algo significativo en solo unas pocas horas, pero hemos descubierto que la tutoría y la práctica nos ayudan a aprender.