---
layout: page
title: Integración continua
permalink: /continuos-integration/
---

---

## Prácticas de Integración Continua

La historia anterior es una ilustración de la Integración Continua que, con suerte, te da una idea de cómo es trabajar con ella para un programador común. Pero, como con cualquier cosa, hay bastantes aspectos que resolver al implementarla en el trabajo diario. Así que ahora revisaremos las **prácticas clave** que necesitamos llevar a cabo.

---

### Poner todo en una línea principal con control de versiones

Hoy en día, casi todos los equipos de software mantienen su código fuente en un **sistema de control de versiones**, de modo que cada desarrollador puede encontrar fácilmente no solo el estado actual del producto, sino también todos los cambios que se le han hecho. Las herramientas de control de versiones permiten que un sistema se **revierta a cualquier punto** de su desarrollo, lo que puede ser muy útil para comprender la historia del sistema, utilizando la **depuración diferencial ("Diff Debugging")** para encontrar errores. Mientras escribo esto, el sistema de control de versiones dominante es **Git**.

Pero si bien el control de versiones es común, algunos equipos no aprovechan al máximo el control de versiones. Mi prueba para un control de versiones completo es que debería poder llegar con un entorno mínimamente configurado (por ejemplo, una computadora portátil con solo el sistema operativo estándar instalado) y ser capaz de **construir y ejecutar el producto fácilmente después de clonar el repositorio**. Esto significa que el repositorio debe devolver de manera confiable el código fuente del producto, las pruebas, el esquema de la base de datos, los datos de prueba, los archivos de configuración, las configuraciones del IDE, los scripts de instalación, las bibliotecas de terceros y cualquier herramienta necesaria para construir el software.

Es posible que notes que dije que el repositorio debe **"devolver"** todos estos elementos, lo que no es lo mismo que "almacenarlos". No tenemos que almacenar el compilador en el repositorio, pero necesitamos poder obtener el compilador correcto. Si extraigo las fuentes del producto del año pasado, es posible que deba poder construirlas con el compilador que usaba el año pasado, no la versión que estoy usando ahora. El repositorio puede hacer esto almacenando un **enlace a un almacenamiento de activos inmutable**, inmutable en el sentido de que una vez que un activo se almacena con una ID, siempre obtendré exactamente ese mismo activo de vuelta. También puedo hacer esto con el código de la biblioteca, siempre que confíe en el almacenamiento de activos y siempre haga referencia a una versión particular, nunca a "la última versión".

Se pueden utilizar esquemas de almacenamiento de activos similares para cualquier cosa que sea demasiado grande, como videos. Clonar un repositorio a menudo significa tomarlo todo, incluso si no es necesario. Al usar referencias a un almacén de activos, los scripts de construcción pueden elegir descargar solo lo que se necesita para una construcción particular.

En general, debemos **almacenar en el control de código fuente todo lo que necesitamos para construir cualquier cosa, pero nada de lo que realmente construimos**. Algunas personas sí mantienen los productos de construcción en el control de código fuente, pero considero que eso es una **"mala práctica" ("smell")**, un indicio de un problema más profundo, generalmente la incapacidad de recrear construcciones de manera confiable. Puede ser útil almacenar en caché los productos de construcción, pero siempre deben tratarse como desechables, y generalmente es bueno asegurarse de que se eliminen rápidamente para que la gente no dependa de ellos cuando no deberían.

Un segundo elemento de este principio es que debe ser fácil **encontrar el código para una pieza de trabajo determinada**. Parte de esto son los **nombres claros y los esquemas de URL**, tanto dentro del repositorio como dentro de la empresa en general. También significa no tener que pasar tiempo averiguando qué rama dentro del sistema de control de versiones usar. La Integración Continua se basa en tener una **línea principal clara ("mainline")**, una única rama compartida que actúa como el estado actual del producto. Esta es la próxima versión que se desplegará en producción.

Los equipos que usan Git en su mayoría usan el nombre **"main"** para la rama principal, pero también a veces vemos "trunk" o el antiguo predeterminado "master". La línea principal es esa rama en el repositorio central, así que para agregar un "commit" a una línea principal llamada `main` necesito primero hacer un "commit" a mi copia local de `main` y luego enviar ese "commit" al servidor central. La rama de seguimiento (llamada algo así como `origin/main`) es una copia de la línea principal en mi máquina local. Sin embargo, puede estar desactualizada, ya que en un entorno de Integración Continua se envían muchos "commits" a la línea principal todos los días.

En la medida de lo posible, debemos utilizar **archivos de texto para definir el producto y su entorno**. Digo esto porque, aunque los sistemas de control de versiones pueden almacenar y rastrear archivos que no son de texto, generalmente no proporcionan ninguna facilidad para ver fácilmente la diferencia entre versiones. Esto hace que sea mucho más difícil entender qué cambio se realizó. Es posible que en el futuro veamos más formatos de almacenamiento que tengan la facilidad de crear diferencias significativas, pero por el momento las diferencias claras están casi completamente reservadas para los formatos de texto. Incluso ahí necesitamos usar formatos de texto que produzcan diferencias comprensibles.

---

## Automatizar la Construcción

Convertir el código fuente en un sistema en funcionamiento a menudo puede ser un proceso complicado que involucra compilación, mover archivos, cargar esquemas en bases de datos, etc. Sin embargo, como la mayoría de las tareas en esta parte del desarrollo de software, se puede automatizar, y como resultado, **debe automatizarse**. Pedir a la gente que escriba comandos extraños o haga clic en cuadros de diálogo es una pérdida de tiempo y un caldo de cultivo para errores.

La mayoría de los entornos de programación modernos incluyen herramientas para **automatizar construcciones**, y dichas herramientas han existido durante mucho tiempo. Las encontré por primera vez con `make`, una de las primeras herramientas de Unix.

Cualquier instrucción para la construcción debe **almacenarse en el repositorio**; en la práctica, esto significa que debemos usar **representaciones de texto**. De esa manera, podemos inspeccionarlas fácilmente para ver cómo funcionan y, lo que es crucial, ver las **diferencias ("diffs")** cuando cambian. Por lo tanto, los equipos que utilizan Integración Continua evitan las herramientas que requieren hacer clic en interfaces de usuario para realizar una construcción o configurar un entorno.

Es posible usar un lenguaje de programación regular para automatizar construcciones; de hecho, las construcciones simples a menudo se capturan como scripts de shell. Pero a medida que las construcciones se complican, es mejor usar una herramienta diseñada pensando en la automatización de la construcción. En parte, esto se debe a que dichas herramientas tendrán funciones incorporadas para tareas de construcción comunes. Pero la razón principal es que las herramientas de construcción funcionan mejor con una forma particular de organizar su lógica: un **modelo computacional alternativo** al que me refiero como **Red de Dependencias**. Una red de dependencias organiza su lógica en tareas que se estructuran como un **grafo de dependencias**.

Una red de dependencias trivialmente simple podría decir que la tarea "test" depende de la tarea "compile". Si invoco la tarea "test", esta buscará si la tarea "compile" necesita ejecutarse y, si es así, la invocará primero. Si la propia tarea "compile" tiene dependencias, la red buscará si necesita invocarlas primero, y así sucesivamente, hacia atrás a lo largo de la cadena de dependencias. Una red de dependencias como esta es útil para los scripts de construcción porque a menudo las tareas llevan mucho tiempo, que se desperdicia si no son necesarias. Si nadie ha cambiado ningún archivo fuente desde la última vez que ejecuté las pruebas, entonces puedo evitar una compilación potencialmente larga.

Para saber si una tarea necesita ejecutarse, la forma más común y sencilla es mirar los **tiempos de modificación de los archivos**. Si alguno de los archivos de entrada a la compilación ha sido modificado más tarde que la salida, entonces sabemos que la compilación debe ejecutarse si se invoca esa tarea.

Un error común es **no incluir todo en la construcción automatizada**. La construcción debe incluir la obtención del **esquema de la base de datos del repositorio** y su puesta en marcha en el entorno de ejecución. Elaboraré mi regla general anterior: cualquiera debería poder traer una máquina limpia, extraer las fuentes del repositorio, emitir un solo comando y tener un sistema en funcionamiento en su propio entorno.

Si bien un programa simple puede necesitar solo una o dos líneas de archivo de script para construirse, los sistemas complejos a menudo tienen un **gran grafo de dependencias**, finamente ajustado para minimizar la cantidad de tiempo requerido para construir las cosas. Este sitio web, por ejemplo, tiene más de mil páginas web. Mi sistema de construcción sabe que si altero el código fuente de esta página, solo tengo que construir esta página. Pero si altero un archivo central en la cadena de herramientas de publicación, entonces necesita reconstruirlos todos. De cualquier manera, invoco el mismo comando en mi editor, y el sistema de construcción determina cuánto hacer.

Dependiendo de lo que necesitemos, podemos necesitar que se construyan diferentes tipos de cosas. Podemos construir un sistema **con o sin código de prueba**, o con diferentes conjuntos de pruebas. Algunos componentes se pueden construir de forma independiente. Un script de construcción debería permitirnos construir **objetivos alternativos** para diferentes casos.

---
¿Hay algo más en el artículo que te gustaría traducir o discutir?

### Hacer que la Construcción sea Auto-Verificable
Tradicionalmente, una construcción significaba compilar, enlazar y todo lo demás necesario para que un programa se ejecutara. Un programa puede ejecutarse, pero eso no significa que haga lo correcto. Los lenguajes modernos de tipado estático pueden detectar muchos errores, pero muchos más se escapan de esa red. Esto es un problema crítico si queremos integrar con la frecuencia que exige la Integración Continua. Si los errores llegan al producto, nos enfrentamos a la abrumadora tarea de corregirlos en una base de código que cambia rápidamente. La prueba manual es demasiado lenta para hacer frente a la frecuencia de los cambios.

Frente a esto, necesitamos asegurarnos de que los errores no lleguen al producto en primer lugar. La técnica principal para lograrlo es una suite de pruebas exhaustiva, que se ejecuta antes de cada integración para eliminar tantos errores como sea posible. Las pruebas no son perfectas, por supuesto, pero pueden detectar muchos errores, los suficientes para ser útiles. Las primeras computadoras que usé realizaban una auto-verificación de memoria visible al arrancar, lo que me llevó a referirme a esto como Código Auto-Verificable.

Escribir código auto-verificable afecta el flujo de trabajo de un programador. Cualquier tarea de programación combina tanto la modificación de la funcionalidad del programa como la ampliación de la suite de pruebas para verificar este comportamiento cambiado. El trabajo de un programador no termina simplemente cuando la nueva característica funciona, sino también cuando tiene pruebas automatizadas para demostrarlo.

Durante las dos décadas transcurridas desde la primera versión de este artículo, he visto cómo los entornos de programación adoptan cada vez más la necesidad de proporcionar las herramientas para que los programadores construyan tales suites de pruebas. El mayor impulso para esto fue JUnit, originalmente escrito por Kent Beck y Erich Gamma, que tuvo un impacto notable en la comunidad Java a finales de los años 90. Esto inspiró marcos de prueba similares para otros lenguajes, a menudo denominados marcos Xunit. Estos enfatizaban una mecánica ligera y amigable para el programador que permitía al programador construir pruebas fácilmente en conjunto con el código del producto. A menudo, estas herramientas tienen algún tipo de barra de progreso gráfica que está en verde si las pruebas pasan, pero se vuelve roja si alguna falla, lo que lleva a frases como "construcción verde" o "barra roja".

La prueba de una suite de pruebas así es que debemos estar seguros de que si las pruebas están en verde, no hay errores significativos en el producto. Me gusta imaginar a un duende travieso que es capaz de hacer modificaciones simples al código del producto, como comentar líneas o invertir condicionales, pero que no puede cambiar las pruebas. Una suite de pruebas sólida nunca permitiría que el duende causara ningún daño sin que una prueba se volviera roja. Y cualquier prueba que falle es suficiente para que la construcción falle, el 99.9% en verde sigue siendo rojo.

El código auto-verificable es tan importante para la Integración Continua que es un prerrequisito necesario. A menudo, la mayor barrera para implementar la Integración Continua es la habilidad insuficiente en las pruebas.

Que el código auto-verificable y la Integración Continua estén tan ligados no es una sorpresa. La Integración Continua se desarrolló originalmente como parte de la Programación Extrema (Extreme Programming) y las pruebas siempre han sido una práctica central de la Programación Extrema. Esta prueba a menudo se realiza en forma de Desarrollo Guiado por Pruebas (Test Driven Development - TDD), una práctica que nos indica que nunca debemos escribir código nuevo a menos que corrija una prueba que hemos escrito justo antes. TDD no es esencial para la Integración Continua, ya que las pruebas se pueden escribir después del código de producción siempre que se realicen antes de la integración. Pero encuentro que, la mayoría de las veces, TDD es la mejor manera de escribir código auto-verificable.

Las pruebas actúan como una verificación automatizada de la salud de la base de código, y si bien las pruebas son el elemento clave de dicha verificación automatizada del código, muchos entornos de programación proporcionan herramientas de verificación adicionales. Los linters pueden detectar malas prácticas de programación y asegurar que el código siga el estilo de formato preferido de un equipo; los escáneres de vulnerabilidades pueden encontrar debilidades de seguridad. Los equipos deben evaluar estas herramientas para incluirlas en el proceso de verificación.

Por supuesto, no podemos contar con las pruebas para encontrarlo todo. Como se ha dicho a menudo: las pruebas no demuestran la ausencia de errores. Sin embargo, la perfección no es el único punto en el que obtenemos un beneficio de una construcción auto-verificable. Las pruebas imperfectas, ejecutadas con frecuencia, son mucho mejores que las pruebas perfectas que nunca se escriben.


### Todo el mundo envía "commits" a la línea principal cada día

La integración es, ante todo, comunicación. La integración permite a los desarrolladores informar a otros desarrolladores sobre los cambios que han realizado. La comunicación frecuente permite a las personas conocer rápidamente cómo evolucionan los cambios.

El único requisito previo para que un desarrollador haga un "commit" a la línea principal es que pueda construir correctamente su código. Esto, por supuesto, incluye pasar las pruebas de construcción. Como en cualquier ciclo de "commit", el desarrollador primero actualiza su copia de trabajo para que coincida con la línea principal, resuelve cualquier conflicto con esta, y luego construye en su máquina local. Si la construcción pasa, entonces puede subir sus cambios a la línea principal.

Si todo el mundo sube sus cambios a la línea principal con frecuencia, los desarrolladores descubren rápidamente si hay un conflicto entre dos desarrolladores. La clave para solucionar problemas rápidamente es encontrarlos rápidamente. Con los desarrolladores haciendo "commits" cada pocas horas, un conflicto puede detectarse a las pocas horas de producirse; en ese momento, no ha sucedido mucho y es fácil de resolver. Los conflictos que permanecen sin detectar durante semanas pueden ser muy difíciles de resolver.

Los conflictos en la base de código se presentan de diferentes formas. Los más fáciles de encontrar y resolver son los conflictos textuales, a menudo llamados "conflictos de fusión", cuando dos desarrolladores editan el mismo fragmento de código de diferentes maneras. Las herramientas de control de versiones los detectan fácilmente una vez que el segundo desarrollador incorpora la línea principal actualizada a su copia de trabajo. El problema más difícil son los conflictos semánticos. Si mi colega cambia el nombre de una función y yo llamo a esa función en mi código recién añadido, el sistema de control de versiones no nos puede ayudar. En un lenguaje de tipado estático, obtenemos un fallo de compilación, lo cual es bastante fácil de detectar, pero en un lenguaje dinámico no obtenemos ninguna ayuda. E incluso la compilación de tipado estático no nos ayuda cuando un colega realiza un cambio en el cuerpo de una función que yo llamo, alterando sutilmente lo que hace. Por eso es tan importante tener código auto-verificable.

Un fallo en una prueba nos alerta de que hay un conflicto entre los cambios, pero todavía tenemos que averiguar cuál es el conflicto y cómo resolverlo. Dado que solo hay unas pocas horas de cambios entre "commits", hay pocos lugares donde el problema podría estar oculto. Además, como no ha cambiado mucho, podemos usar la depuración diferencial ("Diff Debugging") para ayudarnos a encontrar el error.

Mi regla general es que cada desarrollador debería hacer un "commit" a la línea principal todos los días. En la práctica, aquellos con experiencia en Integración Continua se integran con más frecuencia. Cuanto más frecuentemente nos integramos, menos lugares tenemos que buscar errores de conflicto y más rápidamente los resolvemos.

Los "commits" frecuentes animan a los desarrolladores a dividir su trabajo en pequeños fragmentos de unas pocas horas cada uno. Esto ayuda a seguir el progreso y proporciona una sensación de avance. A menudo, al principio la gente siente que no puede hacer algo significativo en solo unas pocas horas, pero hemos descubierto que la tutoría y la práctica nos ayudan a aprender.

### Cada envío a la línea principal debe activar una construcción

Si todos los miembros del equipo integran al menos diariamente, esto debería significar que la línea principal se mantiene en un estado saludable. Sin embargo, en la práctica, las cosas aún pueden salir mal. Esto puede deberse a fallos en la disciplina, a no actualizar y construir antes de un envío, o a diferencias en el entorno entre los espacios de trabajo de los desarrolladores.

Por lo tanto, necesitamos asegurar que cada "commit" sea verificado en un entorno de referencia. La forma habitual de hacer esto es con un Servicio de Integración Continua (Servicio de CI) que monitorea la línea principal. (Ejemplos de Servicios de CI son herramientas como Jenkins, GitHub Actions, Circle CI, etc.). Cada vez que la línea principal recibe un "commit", el servicio de CI extrae el encabezado de la línea principal a un entorno de integración y realiza una construcción completa. Solo una vez que esta construcción de integración esté en verde, el desarrollador puede considerar que la integración está completa. Al asegurar que tenemos una construcción con cada envío, si obtenemos una falla, sabemos que el error se encuentra en ese último envío, lo que reduce el lugar donde tenemos que buscar para corregirlo.

Quiero recalcar aquí que, cuando usamos un Servicio de CI, solo lo usamos en la línea principal, que es la rama principal en la instancia de referencia del sistema de control de versiones. Es común usar un servicio de CI para monitorear y construir desde múltiples ramas, pero el objetivo de la integración es que todos los "commits" coexistan en una sola rama. Si bien puede ser útil usar un servicio de CI para hacer una construcción automatizada para diferentes ramas, eso no es lo mismo que la Integración Continua, y los equipos que usan Integración Continua solo necesitarán que el servicio de CI monitoree una única rama del producto.

Aunque casi todos los equipos utilizan Servicios de CI hoy en día, es perfectamente posible hacer Integración Continua sin uno. Los miembros del equipo pueden extraer manualmente el encabezado de la línea principal a una máquina de integración y realizar una construcción para verificar la integración. Pero tiene poco sentido un proceso manual cuando la automatización está tan fácilmente disponible.

(Este es un buen punto para mencionar que mis colegas en Thoughtworks han contribuido mucho con herramientas de código abierto para la Integración Continua, en particular Cruise Control, el primer Servicio de CI.)

### Solucionar las construcciones fallidas de inmediato

La Integración Continua solo puede funcionar si la línea principal se mantiene en un estado saludable. Si la construcción de integración falla, debe solucionarse de inmediato. Como dice Kent Beck: "nadie tiene una tarea de mayor prioridad que arreglar la construcción". Esto no significa que todos en el equipo tengan que dejar lo que están haciendo para arreglar la construcción; por lo general, solo se necesitan un par de personas para que las cosas vuelvan a funcionar. Sí significa una priorización consciente de una corrección de construcción como una tarea urgente y de alta prioridad.

Normalmente, la mejor manera de arreglar la construcción es revertir el último "commit" de la línea principal, llevando el sistema de vuelta a la última construcción conocida y buena. Si la causa del problema es inmediatamente obvia, entonces se puede solucionar directamente con un nuevo "commit", pero de lo contrario, revertir la línea principal permite a algunas personas averiguar el problema en un entorno de desarrollo separado, permitiendo que el resto del equipo continúe trabajando con la línea principal.

Algunos equipos prefieren eliminar todo riesgo de romper la línea principal utilizando una "Pending Head" (también llamada "Pre-tested", "Delayed" o "Gated Commit"). Para ello, el servicio de CI necesita configurar las cosas para que los "commits" enviados a la línea principal para la integración no pasen inmediatamente a la línea principal. En su lugar, se colocan en otra rama hasta que la construcción se completa y solo se migran a la línea principal después de una construcción en verde. Si bien esta técnica evita cualquier peligro de ruptura de la línea principal, un equipo efectivo rara vez debería ver una línea principal en rojo, y las pocas veces que sucede, su misma visibilidad anima a la gente a aprender cómo evitarlo.

### Mantener la construcción rápida

Todo el objetivo de la Integración Continua es proporcionar retroalimentación rápida. Nada agota más la esencia de la Integración Continua que una construcción que lleva mucho tiempo. Aquí debo admitir cierta diversión de viejo gruñón ante lo que se considera una construcción larga. La mayoría de mis colegas consideran que una construcción que lleva una hora es totalmente irrazonable. Recuerdo equipos soñando con lograr esa velocidad, y ocasionalmente todavía nos encontramos con casos en los que es muy difícil lograr que las construcciones alcancen esa velocidad.

Para la mayoría de los proyectos, sin embargo, la guía de XP de una construcción de diez minutos es perfectamente razonable. La mayoría de nuestros proyectos modernos lo logran. Vale la pena hacer un esfuerzo concentrado para que esto suceda, porque cada minuto recortado del tiempo de construcción es un minuto ahorrado para cada desarrollador cada vez que hacen un "commit". Dado que la Integración Continua exige "commits" frecuentes, esto se suma a una gran cantidad de tiempo.

Si estamos mirando un tiempo de construcción de una hora, entonces lograr una construcción más rápida puede parecer una perspectiva desalentadora. Incluso puede ser desalentador trabajar en un nuevo proyecto y pensar en cómo mantener las cosas rápidas. Para las aplicaciones empresariales, al menos, hemos descubierto que el cuello de botella habitual son las pruebas, particularmente las pruebas que involucran servicios externos como una base de datos.

Probablemente el paso más crucial es comenzar a trabajar en la configuración de un Pipeline de Despliegue. La idea detrás de un pipeline de despliegue (también conocido como pipeline de construcción o construcción por etapas) es que, de hecho, se realizan múltiples construcciones en secuencia. El "commit" a la línea principal activa la primera construcción, lo que yo llamo la construcción de "commit". La construcción de "commit" es la construcción que se necesita cuando alguien envía "commits" a la línea principal. La construcción de "commit" es la que debe hacerse rápidamente, por lo que tomará una serie de atajos que reducirán la capacidad de detectar errores. El truco consiste en equilibrar las necesidades de detección de errores y velocidad para que una buena construcción de "commit" sea lo suficientemente estable para que otras personas puedan trabajar en ella.

Una vez que la construcción de "commit" es buena, otras personas pueden trabajar en el código con confianza. Sin embargo, hay más pruebas, más lentas, que podemos comenzar a hacer. Máquinas adicionales pueden ejecutar más rutinas de prueba en la construcción que tardan más en realizarse.

Un ejemplo simple de esto es un pipeline de despliegue de dos etapas. La primera etapa haría la compilación y ejecutaría pruebas que son pruebas unitarias más localizadas con servicios lentos reemplazados por Test Doubles, como una base de datos falsa en memoria o un "stub" para un servicio externo. Dichas pruebas pueden ejecutarse muy rápido, manteniéndose dentro de la guía de los diez minutos. Sin embargo, no se encontrarán errores que involucren interacciones a mayor escala, particularmente aquellas que involucran la base de datos real. La segunda etapa de la construcción ejecuta una suite de pruebas diferente que sí accede a una base de datos real e implica un comportamiento más de extremo a extremo. Esta suite podría tardar un par de horas en ejecutarse.

En este escenario, las personas usan la primera etapa como la construcción de "commit" y la utilizan como su ciclo principal de CI. Si la construcción secundaria falla, esto puede no tener la misma calidad de "detener todo", pero el equipo sí tiene como objetivo solucionar esos errores lo más rápido posible, mientras mantiene la construcción de "commit" en funcionamiento. Dado que la construcción secundaria puede ser mucho más lenta, es posible que no se ejecute después de cada "commit". En ese caso, se ejecuta con la mayor frecuencia posible, seleccionando la última construcción buena de la etapa de "commit".

Si la construcción secundaria detecta un error, es una señal de que la construcción de "commit" podría necesitar otra prueba. En la medida de lo posible, queremos asegurarnos de que cualquier falla en una etapa posterior conduzca a nuevas pruebas en la construcción de "commit" que hubieran detectado el error, para que el error permanezca corregido en la construcción de "commit". De esta manera, las pruebas de "commit" se fortalecen cada vez que algo las pasa. Hay casos en los que no hay forma de construir una prueba de ejecución rápida que exponga el error, por lo que podemos decidir probar esa condición solo en la construcción secundaria. La mayoría de las veces, afortunadamente, podemos añadir pruebas adecuadas a la construcción de "commit".

Otra forma de acelerar las cosas es usar paralelismo y múltiples máquinas. Los entornos en la nube, en particular, permiten a los equipos lanzar fácilmente una pequeña flota de servidores para las construcciones. Siempre que las pruebas puedan ejecutarse de forma razonablemente independiente, lo que las pruebas bien escritas pueden hacer, el uso de dicha flota puede lograr tiempos de construcción muy rápidos. Dichas construcciones paralelas en la nube también pueden ser útiles para la construcción previa a la integración de un desarrollador.

Mientras consideramos el proceso de construcción más amplio, vale la pena mencionar otra categoría de automatización: la interacción con las dependencias. La mayoría del software utiliza una amplia gama de software dependiente producido por diferentes organizaciones. Los cambios en estas dependencias pueden causar fallas en el producto. Por lo tanto, un equipo debe verificar automáticamente las nuevas versiones de las dependencias e integrarlas en la construcción, esencialmente como si fueran otro miembro del equipo. Esto debe hacerse con frecuencia, generalmente al menos diariamente, dependiendo de la tasa de cambio de las dependencias. Se debe utilizar un enfoque similar con la ejecución de pruebas de contrato (Contract Tests). Si estas interacciones de dependencia se vuelven rojas, no tienen el mismo efecto de "detener la línea" que las fallas de construcción regulares, pero requieren una acción rápida por parte del equipo para investigar y solucionar.

---

### Ocultar el trabajo en curso

La Integración Continua significa integrar tan pronto como haya un pequeño progreso y la construcción sea saludable. Frecuentemente, esto sugiere integrar antes de que una característica visible para el usuario esté completamente formada y lista para su lanzamiento. Por lo tanto, necesitamos considerar cómo manejar el **código latente**: código que forma parte de una característica sin terminar pero que está presente en una versión en vivo.

A algunas personas les preocupa el código latente porque implica incluir código que no tiene calidad de producción en el ejecutable lanzado. Los equipos que practican la Integración Continua se aseguran de que todo el código enviado a la línea principal sea de **calidad de producción**, junto con las pruebas que lo verifican. El código latente puede que nunca se ejecute en producción, pero eso no impide que se pruebe.

Podemos evitar que el código se ejecute en producción utilizando una **Interfaz Clave ("Keystone Interface")**, asegurando que la interfaz que proporciona un camino a la nueva característica sea lo último que añadimos a la base de código. Las pruebas aún pueden verificar el código en todos los niveles, excepto en esa interfaz final. En un sistema bien diseñado, dichos elementos de interfaz deben ser mínimos y, por lo tanto, fáciles de añadir con un breve episodio de programación.

Utilizando el **Lanzamiento Oscuro ("Dark Launching")** podemos probar algunos cambios en producción antes de hacerlos visibles para el usuario. Esta técnica es útil para evaluar el impacto en el rendimiento.

Las Interfaces Clave cubren la mayoría de los casos de código latente, pero para las ocasiones en que eso no es posible, utilizamos **Banderas de Características ("Feature Flags")**. Las banderas de características se verifican cada vez que estamos a punto de ejecutar código latente; se configuran como parte del entorno, quizás en un archivo de configuración específico del entorno. De esa manera, el código latente puede estar activo para pruebas, pero deshabilitado en producción. Además de habilitar la Integración Continua, las banderas de características también facilitan el cambio en tiempo de ejecución para **pruebas A/B y Lanzamientos Canary**. Luego nos aseguramos de eliminar esta lógica rápidamente una vez que una característica se lanza por completo, para que las banderas no desordenen la base de código.

La **Ramificación por Abstracción ("Branch By Abstraction")** es otra técnica para gestionar el código latente, que es particularmente útil para grandes cambios infraestructurales dentro de una base de código. Esencialmente, esto crea una interfaz interna para los módulos que se están cambiando. La interfaz puede entonces enrutar entre la lógica antigua y la nueva, reemplazando gradualmente las rutas de ejecución con el tiempo. Hemos visto esto para cambiar elementos tan omnipresentes como la plataforma de persistencia.

Al introducir una nueva característica, siempre debemos asegurarnos de que podemos **revertir** en caso de problemas. El **Cambio Paralelo ("Parallel Change", también conocido como "expandir-contraer")** divide un cambio en pasos reversibles. Por ejemplo, si renombramos un campo de la base de datos, primero creamos un nuevo campo con el nuevo nombre, luego escribimos en los campos antiguo y nuevo, luego copiamos datos de los campos antiguos existentes, luego leemos del nuevo campo y solo entonces eliminamos el campo antiguo. Podemos revertir cualquiera de estos pasos, lo que no sería posible si hiciéramos un cambio así de una sola vez. Los equipos que utilizan Integración Continua a menudo buscan dividir los cambios de esta manera, manteniéndolos pequeños y fáciles de deshacer.


### Probar en un clon del entorno de producción

El objetivo de las pruebas es detectar, bajo condiciones controladas, cualquier problema que el sistema pueda tener en producción. Una parte significativa de esto es el **entorno** en el cual se ejecutará el sistema de producción. Si probamos en un entorno diferente, cada diferencia resulta en un riesgo de que lo que sucede en las pruebas no suceda en producción.

En consecuencia, queremos configurar nuestro **entorno de prueba para que sea una imitación lo más exacta posible de nuestro entorno de producción**. Utilice el mismo software de base de datos, con las mismas versiones; utilice la misma versión del sistema operativo. Ponga todas las bibliotecas apropiadas que están en el entorno de producción en el entorno de prueba, incluso si el sistema no las utiliza realmente. Utilice las mismas direcciones IP y puertos; ejecútelo en el mismo hardware.

Los **entornos virtuales** facilitan mucho esto en comparación con el pasado. Ejecutamos el software de producción en contenedores y construimos de manera fiable exactamente los mismos contenedores para las pruebas, incluso en el espacio de trabajo de un desarrollador. Vale la pena el esfuerzo y el costo de hacer esto; el precio suele ser pequeño en comparación con la búsqueda de un solo error que surgió del agujero creado por las **discrepancias ambientales**.

Algunos software están diseñados para ejecutarse en múltiples entornos, como diferentes sistemas operativos y versiones de plataforma. El pipeline de despliegue debe organizar las pruebas en todos estos entornos en paralelo.

Un punto a tener en cuenta es cuando el entorno de producción no es tan bueno como el entorno de desarrollo. ¿El software de producción se ejecutará en máquinas conectadas con Wi-Fi deficiente, como los teléfonos inteligentes? Entonces, asegúrese de que un entorno de prueba **imite las malas conexiones de red**.

---

### Todo el mundo puede ver lo que está pasando

La Integración Continua se trata de **comunicación**, por lo que queremos asegurarnos de que todos puedan ver fácilmente el estado del sistema y los cambios que se le han realizado.

Una de las cosas más importantes a comunicar es el **estado de la construcción de la línea principal**. Los Servicios de CI tienen **paneles de control** que permiten a todos ver el estado de cualquier construcción que estén ejecutando. A menudo se enlazan con otras herramientas para difundir información de la construcción a herramientas internas de redes sociales como Slack. Los IDEs a menudo tienen conexiones a estos mecanismos, de modo que los desarrolladores pueden ser alertados mientras aún están dentro de la herramienta que utilizan para gran parte de su trabajo. Muchos equipos solo envían notificaciones de fallos de construcción, pero creo que vale la pena enviar mensajes también cuando hay éxito. De esa manera, la gente se acostumbra a las señales regulares y se hace una idea de la duración de la construcción. Sin mencionar el hecho de que es agradable recibir un "bien hecho" todos los días, incluso si es solo de un servidor de CI.

Los equipos que comparten un espacio físico a menudo tienen algún tipo de **pantalla física siempre encendida** para la construcción. Por lo general, esto toma la forma de una pantalla grande que muestra un panel de control simplificado. Esto es particularmente valioso para alertar a todos sobre una construcción fallida, a menudo utilizando los colores **rojo/verde** en la construcción de "commit" de la línea principal.

Una de las pantallas físicas más antiguas que me gustaba bastante era el uso de **lámparas de lava rojas y verdes**. Una de las características de una lámpara de lava es que, después de estar encendidas un tiempo, comienzan a burbujear. La idea era que si la lámpara roja se encendía, el equipo debía arreglar la construcción antes de que comenzara a burbujear. Las pantallas físicas para el estado de la construcción a menudo se volvían lúdicas, añadiendo una personalidad peculiar al espacio de trabajo de un equipo. Tengo gratos recuerdos de un conejo bailarín.

Además del estado actual de la construcción, estas pantallas pueden mostrar información útil sobre el **historial reciente**, lo que puede ser un indicador de la salud del proyecto. A principios de siglo trabajé con un equipo que tenía un historial de no poder crear construcciones estables. Pusimos un calendario en la pared que mostraba un año completo con un pequeño cuadrado para cada día. Cada día, el grupo de QA ponía una pegatina verde en el día si habían recibido una construcción estable que pasaba las pruebas de "commit", de lo contrario, un cuadrado rojo. Con el tiempo, el calendario reveló el estado del proceso de construcción, mostrando una mejora constante hasta que los cuadrados verdes fueron tan comunes que el calendario desapareció, cumpliendo su propósito.

---

### Automatizar el despliegue

Para hacer Integración Continua necesitamos **múltiples entornos**: uno para ejecutar las pruebas de "commit", probablemente más para ejecutar otras partes del pipeline de despliegue. Dado que estamos moviendo ejecutables entre estos entornos varias veces al día, querremos hacerlo automáticamente. Así que es importante tener **scripts que nos permitan desplegar la aplicación en cualquier entorno fácilmente**.

Con las herramientas modernas de virtualización, contenerización y "serverless" podemos ir más allá. No solo tener scripts para desplegar el producto, sino también **scripts para construir el entorno requerido desde cero**. De esta manera, podemos empezar con un entorno básico disponible en el mercado, crear el entorno que necesitamos para que el producto funcione, instalar el producto y ejecutarlo, todo de forma completamente automática. Si estamos usando **banderas de características** para ocultar el trabajo en curso, entonces estos entornos se pueden configurar con todas las banderas de características activadas, para que estas características puedan ser probadas con todas las interacciones inminentes.

Una consecuencia natural de esto es que estos mismos scripts nos permiten **desplegar en producción con una facilidad similar**. Muchos equipos despliegan código nuevo en producción varias veces al día utilizando estas automatizaciones, pero incluso si elegimos una cadencia menos frecuente, el despliegue automático ayuda a acelerar el proceso y reduce los errores. También es una opción económica, ya que utiliza las mismas capacidades que usamos para desplegar en entornos de prueba.

Si desplegamos en producción automáticamente, una capacidad adicional que encontramos útil es la **reversión automatizada**. Las cosas malas suceden de vez en cuando, y si las sustancias marrones y malolientes golpean el metal giratorio, es bueno poder volver rápidamente al último estado bueno conocido. Ser capaz de revertir automáticamente también reduce gran parte de la tensión del despliegue, animando a la gente a desplegar con más frecuencia y así hacer llegar nuevas características a los usuarios rápidamente. El **Despliegue Azul/Verde ("Blue Green Deployment")** nos permite tanto poner en vivo nuevas versiones rápidamente como revertir con la misma rapidez si es necesario, cambiando el tráfico entre las versiones desplegadas.

El Despliegue Automatizado facilita la configuración de **Lanzamientos Canary ("Canary Releases")**, desplegando una nueva versión de un producto a un subconjunto de nuestros usuarios para detectar problemas antes de lanzarlo a toda la población.

Las aplicaciones móviles son buenos ejemplos donde es esencial automatizar el despliegue en entornos de prueba, en este caso en dispositivos, para que una nueva versión pueda explorarse antes de invocar a los guardianes de la App Store. De hecho, cualquier software ligado a un dispositivo necesita formas de obtener fácilmente nuevas versiones en los dispositivos de prueba.

Al desplegar software como este, recuerde asegurarse de que la **información de la versión sea visible**. Una pantalla de "acerca de" debe contener un ID de construcción que se vincule al control de versiones, los registros deben facilitar la visualización de qué versión del software se está ejecutando, debe haber algún punto final de API que proporcione información de la versión.

---

### Estilos de Integración

Hasta ahora, he descrito una forma de abordar la integración, pero si no es universal, entonces debe haber otras formas. Como con cualquier cosa, cualquier clasificación que dé tiene límites difusos, pero encuentro útil pensar en **tres estilos de manejo de la integración**: Integración Pre-Lanzamiento, Ramas de Características e Integración Continua.

El más antiguo es el que vi en ese almacén en los años 80: la **Integración Pre-Lanzamiento**. Esta ve la integración como una fase de un proyecto de software, una noción que es una parte natural de un **Proceso en Cascada ("Waterfall Process")**. En un proyecto así, el trabajo se divide en unidades, que pueden ser realizadas por individuos o pequeños equipos. Cada unidad es una parte del software, con una interacción mínima con otras unidades. Estas unidades se construyen y prueban por sí mismas (el uso original del término "prueba unitaria"). Luego, una vez que las unidades están listas, las integramos en el producto final. Esta integración ocurre una vez, y es seguida por pruebas de integración y luego un lanzamiento. Así, si pensamos en el trabajo, vemos dos fases: una donde todos trabajan en paralelo en características, seguida de un único flujo de esfuerzo en la integración.

![Trabajo en funcionalidades](/images/work-on-features.png "Trabajo en funcionalidades")

La frecuencia de integración en este estilo está ligada a la **frecuencia de lanzamiento**, generalmente versiones principales del software, usualmente medidas en meses o años. Estos equipos usarán un proceso diferente para las correcciones de errores urgentes, de modo que puedan lanzarse por separado al cronograma de integración regular.

Uno de los enfoques más populares para la integración en la actualidad es el uso de **Ramas de Características ("Feature Branches")**. En este estilo, las características se asignan a individuos o pequeños equipos, muy similar a las unidades en el enfoque anterior. Sin embargo, en lugar de esperar hasta que todas las unidades estén terminadas antes de integrar, los desarrolladores integran su característica en la línea principal tan pronto como está lista. Algunos equipos lanzarán a producción después de cada integración de características, otros prefieren agrupar algunas características para el lanzamiento.

Los equipos que utilizan ramas de características generalmente esperarán que todos obtengan ("pull") de la línea principal regularmente, pero esto es **semi-integración**. Si Rebeca y yo estamos trabajando en características separadas, podríamos obtener de la línea principal todos los días, pero no vemos los cambios del otro hasta que uno de nosotros complete nuestra característica e integre, enviándola a la línea principal. Entonces el otro verá ese código en su siguiente "pull", integrándolo en su copia de trabajo. Así, después de que cada característica es enviada a la línea principal, cada otro desarrollador hará un trabajo de integración para combinar este último envío de la línea principal con su propia rama de características.

Esto es solo semi-integración porque cada desarrollador combina los cambios en la línea principal con su propia rama local. La integración completa no puede ocurrir hasta que un desarrollador envíe sus cambios, lo que provoca otra ronda de semi-integraciones. Incluso si Rebeca y yo obtenemos los mismos cambios de la línea principal, solo nos hemos integrado con esos cambios, no con las ramas del otro.

Con la **Integración Continua**, cada día todos estamos enviando nuestros cambios a la línea principal y obteniendo los cambios de todos los demás en nuestro propio trabajo. Esto lleva a muchos más episodios de trabajo de integración, pero **cada episodio es mucho más pequeño**. Es mucho más fácil combinar unas pocas horas de trabajo en una base de código que combinar varios días.

---

## Beneficios de la Integración Continua

Al discutir los méritos relativos de los tres estilos de integración, la mayor parte de la discusión trata verdaderamente sobre la **frecuencia de la integración**. Tanto la Integración Pre-Lanzamiento como la Ramificación de Características pueden operar a diferentes frecuencias y es posible cambiar la frecuencia de integración sin cambiar el estilo de integración. Si estamos usando la Integración Pre-Lanzamiento, hay una gran diferencia entre lanzamientos mensuales y lanzamientos anuales. La Ramificación de Características generalmente funciona con una frecuencia más alta, porque la integración ocurre cuando cada característica se envía individualmente a la línea principal, a diferencia de esperar a agrupar un montón de unidades. Si un equipo está haciendo Ramificación de Características y todas sus características requieren menos de un día de trabajo para construir, entonces son efectivamente lo mismo que la Integración Continua. Pero la Integración Continua es diferente en que se define como un **estilo de alta frecuencia**. La Integración Continua se empeña en establecer la frecuencia de integración como un objetivo en sí mismo, y no la vincula a la finalización de características o a la frecuencia de lanzamiento.

De ello se deduce que la mayoría de los equipos pueden ver una mejora útil en los factores que discutiré a continuación al aumentar su frecuencia sin cambiar su estilo. Hay beneficios significativos al reducir el tamaño de las características de dos meses a dos semanas. La Integración Continua tiene la ventaja de establecer la **integración de alta frecuencia como la línea de base**, estableciendo hábitos y prácticas que la hacen sostenible.

---

Aquí tienes la traducción al español del texto, manteniendo el contexto de la Integración Continua:

---

### Reducción del riesgo de retrasos en la entrega

Es muy difícil estimar cuánto tiempo lleva realizar una integración compleja. A veces puede ser un esfuerzo fusionar en Git, pero luego todo funciona bien. Otras veces puede ser una fusión rápida, pero un error de integración sutil tarda días en encontrarse y corregirse. Cuanto más largo sea el tiempo entre integraciones, más código habrá que integrar, más tiempo llevará, pero lo que es peor es el **aumento de la imprevisibilidad**.

Todo esto convierte la **integración previa al lanzamiento** en una pesadilla particular. Debido a que la integración es uno de los últimos pasos antes del lanzamiento, el tiempo ya es escaso y la presión es alta. Tener una fase difícil de predecir al final del día significa que tenemos un **riesgo significativo muy difícil de mitigar**. Por eso mi recuerdo de los años 80 es tan fuerte, y no es la única vez que he visto proyectos atrapados en un **infierno de integración**, donde cada vez que arreglan un error de integración, aparecen dos más.

Cualquier paso para **aumentar la frecuencia de integración reduce este riesgo**. Cuanta menos integración haya que hacer, menos tiempo desconocido habrá antes de que una nueva versión esté lista. La **Ramificación de Características ("Feature Branching")** ayuda al empujar este trabajo de integración a flujos de características individuales, de modo que, si se deja solo, un flujo puede enviarse a la línea principal tan pronto como la característica esté lista.

Pero ese "si se deja solo" es importante. Si alguien más envía cambios a la línea principal, entonces introducimos algo de trabajo de integración antes de que la característica esté terminada. Debido a que las ramas están aisladas, un desarrollador que trabaja en una rama no tiene mucha visibilidad sobre qué otras características pueden enviarse y cuánto trabajo implicaría integrarlas. Si bien existe el peligro de que las características de alta prioridad puedan enfrentar retrasos en la integración, podemos gestionarlo evitando los envíos de características de menor prioridad.

La **Integración Continua elimina eficazmente el riesgo de entrega**. Las integraciones son tan pequeñas que generalmente se realizan sin problemas. Una integración incómoda sería una que tarde más de unos pocos minutos en resolverse. El peor de los casos sería un conflicto que haga que alguien reinicie su trabajo desde cero, pero eso aún sería menos de un día de trabajo perdido, y por lo tanto no será algo que probablemente preocupe a una junta de accionistas. Además, estamos realizando la integración regularmente a medida que desarrollamos el software, por lo que podemos enfrentar problemas mientras tenemos más tiempo para lidiar con ellos y podemos practicar cómo resolverlos.

Incluso si un equipo no está lanzando a producción regularmente, la Integración Continua es importante porque permite a todos **ver exactamente cuál es el estado del producto**. No hay esfuerzos de integración ocultos que deban hacerse antes del lanzamiento; cualquier esfuerzo en la integración ya está incorporado.

---

### Menos tiempo desperdiciado en la integración

No he visto estudios serios que midan cómo el tiempo dedicado a la integración se relaciona con el tamaño de las integraciones, pero mi evidencia anecdótica sugiere fuertemente que la relación **no es lineal**. Si hay el doble de código para integrar, es más probable que lleve cuatro veces más tiempo realizar la integración. Es como cuando necesitamos tres líneas para conectar completamente tres nodos, pero seis líneas para conectar cuatro de ellos. La integración se trata de **conexiones**, de ahí el aumento no lineal, uno que se refleja en la experiencia de mis colegas.

En organizaciones que utilizan **ramas de características**, gran parte de este tiempo perdido lo siente el individuo. Varias horas dedicadas a intentar hacer un "rebase" sobre un gran cambio en la línea principal son frustrantes. Unos días esperando una revisión de código en una solicitud de extracción terminada, durante la cual ocurre otro gran cambio en la línea principal, es aún más frustrante. Tener que dejar de lado el trabajo en una nueva característica para depurar un problema encontrado en una prueba de integración de una característica terminada hace dos semanas **mina la productividad**.

Cuando hacemos Integración Continua, la integración es generalmente un **evento sin incidentes**. Bajo la línea principal, ejecuto la construcción y envío mis cambios. Si hay un conflicto, la pequeña cantidad de código que he escrito está fresca en mi mente, por lo que suele ser fácil de ver. El flujo de trabajo es regular, por lo que estamos practicando en él, y estamos incentivados a automatizarlo tanto como sea posible.

Al igual que muchos de estos efectos no lineales, la integración puede convertirse fácilmente en una trampa donde la gente aprende la lección equivocada. Una integración difícil puede ser tan traumática que un equipo decide hacer integraciones con menos frecuencia, lo que solo **exacerba el problema en el futuro**.

Lo que está sucediendo aquí es que estamos viendo una **colaboración mucho más estrecha** entre los miembros del equipo. Si dos desarrolladores toman decisiones que entran en conflicto, lo descubrimos cuando integramos. Así, cuanto menos tiempo haya entre integraciones, menos tiempo pasará antes de que detectemos el conflicto, y podremos lidiar con el conflicto antes de que se haga demasiado grande. Con la **integración de alta frecuencia**, nuestro sistema de control de código fuente se convierte en un **canal de comunicación**, uno que puede comunicar cosas que de otra manera no se dirían.

---

### Menos Errores

Los errores (bugs) son esas cosas desagradables que destruyen la confianza y alteran los cronogramas y las reputaciones. Los errores en el software desplegado hacen que los usuarios se enojen con nosotros. Los errores que aparecen durante el desarrollo regular se interponen en nuestro camino, dificultando que el resto del software funcione correctamente.

La Integración Continua no elimina los errores, pero sí los hace **drásticamente más fáciles de encontrar y eliminar**. Esto se debe menos a la integración de alta frecuencia y más a la **introducción esencial del código auto-verificable**. La Integración Continua no funciona sin código auto-verificable porque, sin pruebas decentes, no podemos mantener una línea principal saludable. La Integración Continua, por lo tanto, establece un **régimen regular de pruebas**. Si las pruebas son inadecuadas, el equipo lo notará rápidamente y podrá tomar medidas correctivas. Si aparece un error debido a un conflicto semántico, es fácil de detectar porque solo hay una pequeña cantidad de código que integrar. Las integraciones frecuentes también funcionan bien con la **depuración diferencial ("Diff Debugging")**, por lo que incluso un error detectado semanas después puede reducirse a un pequeño cambio.

Los errores también son **acumulativos**. Cuantos más errores tenemos, más difícil es eliminar cada uno. Esto se debe en parte a que se producen **interacciones de errores**, donde los fallos se muestran como resultado de múltiples defectos, lo que dificulta la búsqueda de cada defecto. También es psicológico: la gente tiene menos energía para encontrar y eliminar errores cuando hay muchos. Por lo tanto, el código auto-verificable reforzado por la Integración Continua tiene otro **efecto exponencial en la reducción de los problemas causados por defectos**.

Esto se topa con otro fenómeno que a mucha gente le resulta contraintuitivo. Al ver con qué frecuencia introducir un cambio significa introducir errores, la gente concluye que para tener un software de alta fiabilidad necesitan ralentizar la tasa de lanzamiento. Esto fue firmemente contradicho por el **programa de investigación DORA** liderado por Nicole Forsgren. Descubrieron que los equipos de élite desplegaban en producción más rápidamente, con más frecuencia y tenían una incidencia de fallos dramáticamente menor cuando realizaban estos cambios. La investigación también encuentra que los equipos tienen niveles más altos de rendimiento cuando tienen **tres o menos ramas activas** en el repositorio de código de la aplicación, **fusionan ramas a la línea principal al menos una vez al día**, y **no tienen congelaciones de código ni fases de integración**.

---

### Habilita la refactorización para una productividad sostenida

La mayoría de los equipos observan que, con el tiempo, las bases de código se deterioran. Las decisiones iniciales fueron buenas en su momento, pero ya no son óptimas después de seis meses de trabajo. Pero cambiar el código para incorporar lo que el equipo ha aprendido significa introducir **cambios profundos en el código existente**, lo que resulta en fusiones difíciles que consumen tiempo y están llenas de riesgo. Todos recuerdan esa vez que alguien hizo lo que sería un buen cambio para el futuro, pero causó días de esfuerzo rompiendo el trabajo de otras personas. Dada esa experiencia, nadie quiere reelaborar la estructura del código existente, aunque ahora sea incómodo para todos construir sobre él, **ralentizando así la entrega de nuevas características**.

La **refactorización** es una técnica esencial para atenuar e incluso revertir este proceso de deterioro. Un equipo que refactoriza regularmente tiene una técnica disciplinada para mejorar la estructura de una base de código utilizando **pequeñas transformaciones que preservan el comportamiento del código**. Estas características de las transformaciones reducen en gran medida sus posibilidades de introducir errores, y pueden hacerse rápidamente, especialmente cuando se apoyan en una base de código auto-verificable. Aplicando la refactorización en cada oportunidad, un equipo puede mejorar la estructura de una base de código existente, haciéndola **más fácil y rápida para añadir nuevas funcionalidades**.

Pero esta historia feliz puede ser torpedeada por los **problemas de integración**. Una sesión de refactorización de dos semanas puede mejorar mucho el código, pero resultar en fusiones largas porque todos los demás han estado trabajando las últimas dos semanas con la estructura antigua. Esto eleva los costos de la refactorización a niveles prohibitivos. La **integración frecuente** resuelve este dilema al asegurar que tanto quienes realizan la refactorización como todos los demás sincronicen regularmente su trabajo. Cuando se utiliza la Integración Continua, si alguien realiza cambios intrusivos en una biblioteca central que estoy utilizando, solo tengo que ajustar unas pocas horas de programación a estos cambios. Si hacen algo que choca con la dirección de mis cambios, lo sé de inmediato, así que tengo la oportunidad de hablar con ellos para que podamos encontrar un mejor camino a seguir.

Hasta ahora en este artículo he planteado varias nociones contraintuitivas sobre los méritos de la integración de alta frecuencia: que cuanto más a menudo integramos, menos tiempo dedicamos a integrar, y que la integración frecuente conduce a menos errores. Aquí está quizás la **noción contraintuitiva más importante en el desarrollo de software**: que los equipos que dedican mucho esfuerzo a mantener su base de código saludable entregan características más rápido y más barato. El tiempo invertido en escribir pruebas y refactorizar ofrece retornos impresionantes en la velocidad de entrega, y la Integración Continua es una parte fundamental para que eso funcione en un entorno de equipo.

---

## El lanzamiento a producción es una decisión de negocio

Imaginemos que estamos demostrando una nueva característica a un interesado, y ella reacciona diciendo: "esto es realmente genial y tendría un gran impacto comercial. ¿Cuánto tiempo falta para que podamos ponerlo en vivo?". Si esa característica se muestra en una rama no integrada, la respuesta puede ser semanas o meses, especialmente si hay poca automatización en el camino a producción. La Integración Continua nos permite mantener una **Línea Principal Lista para el Lanzamiento ("Release-Ready Mainline")**, lo que significa que la decisión de lanzar la última versión del producto a producción es **puramente una decisión de negocio**. Si los interesados quieren que lo último esté en vivo, es cuestión de minutos ejecutar un pipeline automatizado para que así sea. Esto permite a los clientes del software un mayor control sobre cuándo se lanzan las características y los anima a colaborar más estrechamente con el equipo de desarrollo.

La Integración Continua y una Línea Principal Lista para el Lanzamiento eliminan una de las mayores barreras para el despliegue frecuente. El despliegue frecuente es valioso porque permite a nuestros usuarios obtener nuevas características más rápidamente, dar retroalimentación más rápida sobre esas características y, en general, **volverse más colaborativos** en el ciclo de desarrollo. Esto ayuda a **derribar las barreras entre los clientes y el desarrollo**, barreras que, en mi opinión, son las mayores barreras para el éxito del desarrollo de software.

---

## Cuándo NO debemos usar la Integración Continua

Todos esos beneficios suenan bastante atractivos. Pero las personas tan experimentadas (o cínicas) como yo siempre desconfían de una simple lista de beneficios. Pocas cosas vienen sin un costo, y las decisiones sobre arquitectura y procesos suelen ser una cuestión de compensaciones.

Pero confieso que la Integración Continua es uno de esos casos raros en los que hay **pocas desventajas para un equipo comprometido y hábil** que la utilice. El costo impuesto por la integración esporádica es tan grande que casi cualquier equipo puede beneficiarse aumentando su frecuencia de integración. Hay un límite hasta donde los beneficios se acumulan, pero ese límite se sitúa en horas en lugar de días, que es exactamente el territorio de la Integración Continua. La interacción entre el **código auto-verificable, la Integración Continua y la Refactorización** es particularmente fuerte. Hemos estado utilizando este enfoque durante dos décadas en Thoughtworks, y nuestra única pregunta es cómo hacerlo de manera más efectiva; el enfoque central está probado.

Pero eso no significa que la Integración Continua sea para todos. Podrás notar que dije que "hay pocas desventajas para un **equipo comprometido y hábil** que la utilice". Esos dos adjetivos indican los contextos en los que la Integración Continua no es una buena opción.

Por "comprometido", me refiero a un equipo que está trabajando **a tiempo completo en un producto**. Un buen contraejemplo de esto es un proyecto clásico de código abierto, donde hay uno o dos mantenedores y muchos colaboradores. En tal situación, incluso los mantenedores solo dedican unas pocas horas a la semana al proyecto, no conocen muy bien a los colaboradores y no tienen una buena visibilidad de cuándo contribuyen los colaboradores o los estándares que deben seguir al hacerlo. Este es el entorno que llevó a un flujo de trabajo de ramas de características y solicitudes de extracción. En un contexto así, la Integración Continua no es plausible, aunque los esfuerzos para aumentar la frecuencia de integración aún pueden ser valiosos.

La Integración Continua es más adecuada para equipos que trabajan **a tiempo completo en un producto**, como suele ser el caso del software comercial. Pero hay un gran punto intermedio entre el código abierto clásico y el modelo de tiempo completo. Necesitamos usar nuestro juicio sobre qué política de integración utilizar que se ajuste al compromiso del equipo.

El segundo adjetivo se refiere a la **habilidad del equipo para seguir las prácticas necesarias**. Si un equipo intenta la Integración Continua sin una suite de pruebas sólida, se encontrará con todo tipo de problemas porque no tiene un mecanismo para eliminar los errores. Si no automatizan, la integración llevará demasiado tiempo, interfiriendo con el flujo de desarrollo. Si la gente no es disciplinada para asegurar que sus envíos a la línea principal se hagan con construcciones en verde, entonces la línea principal terminará rota todo el tiempo, interponiéndose en el trabajo de todos.

Cualquiera que esté considerando introducir la Integración Continua debe tener en cuenta estas habilidades. Instituir la Integración Continua sin **código auto-verificable** no funcionará, y también dará una impresión inexacta de lo que es la Integración Continua cuando se hace bien.

Dicho esto, no creo que las exigencias de habilidad sean particularmente difíciles. No necesitamos desarrolladores "estrellas" para que este proceso funcione en un equipo. (De hecho, los desarrolladores "estrellas" suelen ser una barrera, ya que las personas que se consideran así generalmente no son muy disciplinadas). Las habilidades para estas prácticas técnicas no son tan difíciles de aprender, generalmente el problema es encontrar un buen maestro y formar los hábitos que cristalizan la disciplina. Una vez que el equipo le coge el tranquillo al flujo, generalmente se siente cómodo, suave y rápido.

---

## Introduciendo la Integración Continua

Una de las cosas difíciles de describir cómo introducir una práctica como la Integración Continua es que el camino **depende mucho de dónde se empieza**. Al escribir esto, no sé qué tipo de código estás trabajando, qué habilidades y hábitos posee tu equipo, y mucho menos el contexto organizacional más amplio. Todo lo que alguien como yo puede hacer es señalar algunas **señales comunes**, con la esperanza de que te ayuden a encontrar tu propio camino.

Al introducir cualquier nueva práctica, es importante tener claro **por qué lo estamos haciendo**. Mi lista de beneficios anterior incluye las razones más comunes, pero diferentes contextos conducen a un nivel diferente de importancia para ellos. Algunos beneficios son más difíciles de apreciar que otros. Reducir el desperdicio en la integración aborda un problema frustrante y puede percibirse fácilmente a medida que avanzamos. Habilitar la refactorización para reducir la "mugre" en un sistema y mejorar la productividad general es más difícil de ver. Lleva tiempo antes de que veamos un efecto, y es difícil comparar con el contrafactual. Sin embargo, este es probablemente el beneficio más valioso de la Integración Continua.

La lista de prácticas anteriores indica las **habilidades que un equipo necesita aprender** para que la Integración Continua funcione. Algunas de ellas pueden aportar valor incluso antes de acercarse a la alta frecuencia de integración. El código auto-verificable añade estabilidad a un sistema incluso con "commits" poco frecuentes.

Un objetivo puede ser **duplicar la frecuencia de integración**. Si las ramas de características suelen durar diez días, averigüa cómo reducirlas a cinco. Esto puede implicar una mejor automatización de la construcción y las pruebas, y un pensamiento creativo sobre cómo una tarea grande puede dividirse en tareas más pequeñas e integradas de forma independiente. Si utilizamos revisiones previas a la integración, podríamos incluir pasos explícitos en esas revisiones para verificar la cobertura de las pruebas y fomentar "commits" más pequeños.

Si estás iniciando un **nuevo proyecto**, podemos comenzar con la Integración Continua desde el principio. Debemos estar atentos a los **tiempos de construcción** y tomar medidas tan pronto como comencemos a ir más lento de la regla de los diez minutos. Actuando rápidamente haremos las reestructuraciones necesarias antes de que la base de código sea tan grande que se convierta en un gran problema.

Por encima de todo, debemos **obtener ayuda**. Debemos encontrar a alguien que haya hecho Integración Continua antes para que nos ayude. Como cualquier técnica nueva, es difícil introducirla cuando no sabemos cómo será el resultado final. Puede costar dinero obtener este apoyo, pero de lo contrario pagaremos en tiempo y productividad perdidos. (Descargo de responsabilidad / Anuncio: sí, en Thoughtworks ofrecemos consultoría en esta área. Después de todo, hemos cometido la mayoría de los errores que se pueden cometer).

---