---
layout: page
title: Integración continua
permalink: /continuos-integration/
---

## Hacer que la Construcción sea Auto-Verificable
Tradicionalmente, una construcción significaba compilar, enlazar y todo lo demás necesario para que un programa se ejecutara. Un programa puede ejecutarse, pero eso no significa que haga lo correcto. Los lenguajes modernos de tipado estático pueden detectar muchos errores, pero muchos más se escapan de esa red. Esto es un problema crítico si queremos integrar con la frecuencia que exige la Integración Continua. Si los errores llegan al producto, nos enfrentamos a la abrumadora tarea de corregirlos en una base de código que cambia rápidamente. La prueba manual es demasiado lenta para hacer frente a la frecuencia de los cambios.

Frente a esto, necesitamos asegurarnos de que los errores no lleguen al producto en primer lugar. La técnica principal para lograrlo es una suite de pruebas exhaustiva, que se ejecuta antes de cada integración para eliminar tantos errores como sea posible. Las pruebas no son perfectas, por supuesto, pero pueden detectar muchos errores, los suficientes para ser útiles. Las primeras computadoras que usé realizaban una auto-verificación de memoria visible al arrancar, lo que me llevó a referirme a esto como Código Auto-Verificable.

Escribir código auto-verificable afecta el flujo de trabajo de un programador. Cualquier tarea de programación combina tanto la modificación de la funcionalidad del programa como la ampliación de la suite de pruebas para verificar este comportamiento cambiado. El trabajo de un programador no termina simplemente cuando la nueva característica funciona, sino también cuando tiene pruebas automatizadas para demostrarlo.

Durante las dos décadas transcurridas desde la primera versión de este artículo, he visto cómo los entornos de programación adoptan cada vez más la necesidad de proporcionar las herramientas para que los programadores construyan tales suites de pruebas. El mayor impulso para esto fue JUnit, originalmente escrito por Kent Beck y Erich Gamma, que tuvo un impacto notable en la comunidad Java a finales de los años 90. Esto inspiró marcos de prueba similares para otros lenguajes, a menudo denominados marcos Xunit. Estos enfatizaban una mecánica ligera y amigable para el programador que permitía al programador construir pruebas fácilmente en conjunto con el código del producto. A menudo, estas herramientas tienen algún tipo de barra de progreso gráfica que está en verde si las pruebas pasan, pero se vuelve roja si alguna falla, lo que lleva a frases como "construcción verde" o "barra roja".

La prueba de una suite de pruebas así es que debemos estar seguros de que si las pruebas están en verde, no hay errores significativos en el producto. Me gusta imaginar a un duende travieso que es capaz de hacer modificaciones simples al código del producto, como comentar líneas o invertir condicionales, pero que no puede cambiar las pruebas. Una suite de pruebas sólida nunca permitiría que el duende causara ningún daño sin que una prueba se volviera roja. Y cualquier prueba que falle es suficiente para que la construcción falle, el 99.9% en verde sigue siendo rojo.

El código auto-verificable es tan importante para la Integración Continua que es un prerrequisito necesario. A menudo, la mayor barrera para implementar la Integración Continua es la habilidad insuficiente en las pruebas.

Que el código auto-verificable y la Integración Continua estén tan ligados no es una sorpresa. La Integración Continua se desarrolló originalmente como parte de la Programación Extrema (Extreme Programming) y las pruebas siempre han sido una práctica central de la Programación Extrema. Esta prueba a menudo se realiza en forma de Desarrollo Guiado por Pruebas (Test Driven Development - TDD), una práctica que nos indica que nunca debemos escribir código nuevo a menos que corrija una prueba que hemos escrito justo antes. TDD no es esencial para la Integración Continua, ya que las pruebas se pueden escribir después del código de producción siempre que se realicen antes de la integración. Pero encuentro que, la mayoría de las veces, TDD es la mejor manera de escribir código auto-verificable.

Las pruebas actúan como una verificación automatizada de la salud de la base de código, y si bien las pruebas son el elemento clave de dicha verificación automatizada del código, muchos entornos de programación proporcionan herramientas de verificación adicionales. Los linters pueden detectar malas prácticas de programación y asegurar que el código siga el estilo de formato preferido de un equipo; los escáneres de vulnerabilidades pueden encontrar debilidades de seguridad. Los equipos deben evaluar estas herramientas para incluirlas en el proceso de verificación.

Por supuesto, no podemos contar con las pruebas para encontrarlo todo. Como se ha dicho a menudo: las pruebas no demuestran la ausencia de errores. Sin embargo, la perfección no es el único punto en el que obtenemos un beneficio de una construcción auto-verificable. Las pruebas imperfectas, ejecutadas con frecuencia, son mucho mejores que las pruebas perfectas que nunca se escriben.


## Todo el mundo envía "commits" a la línea principal cada día
La integración es, ante todo, comunicación. La integración permite a los desarrolladores informar a otros desarrolladores sobre los cambios que han realizado. La comunicación frecuente permite a las personas conocer rápidamente cómo evolucionan los cambios.

El único requisito previo para que un desarrollador haga un "commit" a la línea principal es que pueda construir correctamente su código. Esto, por supuesto, incluye pasar las pruebas de construcción. Como en cualquier ciclo de "commit", el desarrollador primero actualiza su copia de trabajo para que coincida con la línea principal, resuelve cualquier conflicto con esta, y luego construye en su máquina local. Si la construcción pasa, entonces puede subir sus cambios a la línea principal.

Si todo el mundo sube sus cambios a la línea principal con frecuencia, los desarrolladores descubren rápidamente si hay un conflicto entre dos desarrolladores. La clave para solucionar problemas rápidamente es encontrarlos rápidamente. Con los desarrolladores haciendo "commits" cada pocas horas, un conflicto puede detectarse a las pocas horas de producirse; en ese momento, no ha sucedido mucho y es fácil de resolver. Los conflictos que permanecen sin detectar durante semanas pueden ser muy difíciles de resolver.

Los conflictos en la base de código se presentan de diferentes formas. Los más fáciles de encontrar y resolver son los conflictos textuales, a menudo llamados "conflictos de fusión", cuando dos desarrolladores editan el mismo fragmento de código de diferentes maneras. Las herramientas de control de versiones los detectan fácilmente una vez que el segundo desarrollador incorpora la línea principal actualizada a su copia de trabajo. El problema más difícil son los conflictos semánticos. Si mi colega cambia el nombre de una función y yo llamo a esa función en mi código recién añadido, el sistema de control de versiones no nos puede ayudar. En un lenguaje de tipado estático, obtenemos un fallo de compilación, lo cual es bastante fácil de detectar, pero en un lenguaje dinámico no obtenemos ninguna ayuda. E incluso la compilación de tipado estático no nos ayuda cuando un colega realiza un cambio en el cuerpo de una función que yo llamo, alterando sutilmente lo que hace. Por eso es tan importante tener código auto-verificable.

Un fallo en una prueba nos alerta de que hay un conflicto entre los cambios, pero todavía tenemos que averiguar cuál es el conflicto y cómo resolverlo. Dado que solo hay unas pocas horas de cambios entre "commits", hay pocos lugares donde el problema podría estar oculto. Además, como no ha cambiado mucho, podemos usar la depuración diferencial ("Diff Debugging") para ayudarnos a encontrar el error.

Mi regla general es que cada desarrollador debería hacer un "commit" a la línea principal todos los días. En la práctica, aquellos con experiencia en Integración Continua se integran con más frecuencia. Cuanto más frecuentemente nos integramos, menos lugares tenemos que buscar errores de conflicto y más rápidamente los resolvemos.

Los "commits" frecuentes animan a los desarrolladores a dividir su trabajo en pequeños fragmentos de unas pocas horas cada uno. Esto ayuda a seguir el progreso y proporciona una sensación de avance. A menudo, al principio la gente siente que no puede hacer algo significativo en solo unas pocas horas, pero hemos descubierto que la tutoría y la práctica nos ayudan a aprender.

## Cada envío a la línea principal debe activar una construcción
Si todos los miembros del equipo integran al menos diariamente, esto debería significar que la línea principal se mantiene en un estado saludable. Sin embargo, en la práctica, las cosas aún pueden salir mal. Esto puede deberse a fallos en la disciplina, a no actualizar y construir antes de un envío, o a diferencias en el entorno entre los espacios de trabajo de los desarrolladores.

Por lo tanto, necesitamos asegurar que cada "commit" sea verificado en un entorno de referencia. La forma habitual de hacer esto es con un Servicio de Integración Continua (Servicio de CI) que monitorea la línea principal. (Ejemplos de Servicios de CI son herramientas como Jenkins, GitHub Actions, Circle CI, etc.). Cada vez que la línea principal recibe un "commit", el servicio de CI extrae el encabezado de la línea principal a un entorno de integración y realiza una construcción completa. Solo una vez que esta construcción de integración esté en verde, el desarrollador puede considerar que la integración está completa. Al asegurar que tenemos una construcción con cada envío, si obtenemos una falla, sabemos que el error se encuentra en ese último envío, lo que reduce el lugar donde tenemos que buscar para corregirlo.

Quiero recalcar aquí que, cuando usamos un Servicio de CI, solo lo usamos en la línea principal, que es la rama principal en la instancia de referencia del sistema de control de versiones. Es común usar un servicio de CI para monitorear y construir desde múltiples ramas, pero el objetivo de la integración es que todos los "commits" coexistan en una sola rama. Si bien puede ser útil usar un servicio de CI para hacer una construcción automatizada para diferentes ramas, eso no es lo mismo que la Integración Continua, y los equipos que usan Integración Continua solo necesitarán que el servicio de CI monitoree una única rama del producto.

Aunque casi todos los equipos utilizan Servicios de CI hoy en día, es perfectamente posible hacer Integración Continua sin uno. Los miembros del equipo pueden extraer manualmente el encabezado de la línea principal a una máquina de integración y realizar una construcción para verificar la integración. Pero tiene poco sentido un proceso manual cuando la automatización está tan fácilmente disponible.

(Este es un buen punto para mencionar que mis colegas en Thoughtworks han contribuido mucho con herramientas de código abierto para la Integración Continua, en particular Cruise Control, el primer Servicio de CI.)

## Solucionar las construcciones fallidas de inmediato

La Integración Continua solo puede funcionar si la línea principal se mantiene en un estado saludable. Si la construcción de integración falla, debe solucionarse de inmediato. Como dice Kent Beck: "nadie tiene una tarea de mayor prioridad que arreglar la construcción". Esto no significa que todos en el equipo tengan que dejar lo que están haciendo para arreglar la construcción; por lo general, solo se necesitan un par de personas para que las cosas vuelvan a funcionar. Sí significa una priorización consciente de una corrección de construcción como una tarea urgente y de alta prioridad.

Normalmente, la mejor manera de arreglar la construcción es revertir el último "commit" de la línea principal, llevando el sistema de vuelta a la última construcción conocida y buena. Si la causa del problema es inmediatamente obvia, entonces se puede solucionar directamente con un nuevo "commit", pero de lo contrario, revertir la línea principal permite a algunas personas averiguar el problema en un entorno de desarrollo separado, permitiendo que el resto del equipo continúe trabajando con la línea principal.

Algunos equipos prefieren eliminar todo riesgo de romper la línea principal utilizando una "Pending Head" (también llamada "Pre-tested", "Delayed" o "Gated Commit"). Para ello, el servicio de CI necesita configurar las cosas para que los "commits" enviados a la línea principal para la integración no pasen inmediatamente a la línea principal. En su lugar, se colocan en otra rama hasta que la construcción se completa y solo se migran a la línea principal después de una construcción en verde. Si bien esta técnica evita cualquier peligro de ruptura de la línea principal, un equipo efectivo rara vez debería ver una línea principal en rojo, y las pocas veces que sucede, su misma visibilidad anima a la gente a aprender cómo evitarlo.

## Mantener la construcción rápida
Todo el objetivo de la Integración Continua es proporcionar retroalimentación rápida. Nada agota más la esencia de la Integración Continua que una construcción que lleva mucho tiempo. Aquí debo admitir cierta diversión de viejo gruñón ante lo que se considera una construcción larga. La mayoría de mis colegas consideran que una construcción que lleva una hora es totalmente irrazonable. Recuerdo equipos soñando con lograr esa velocidad, y ocasionalmente todavía nos encontramos con casos en los que es muy difícil lograr que las construcciones alcancen esa velocidad.

Para la mayoría de los proyectos, sin embargo, la guía de XP de una construcción de diez minutos es perfectamente razonable. La mayoría de nuestros proyectos modernos lo logran. Vale la pena hacer un esfuerzo concentrado para que esto suceda, porque cada minuto recortado del tiempo de construcción es un minuto ahorrado para cada desarrollador cada vez que hacen un "commit". Dado que la Integración Continua exige "commits" frecuentes, esto se suma a una gran cantidad de tiempo.

Si estamos mirando un tiempo de construcción de una hora, entonces lograr una construcción más rápida puede parecer una perspectiva desalentadora. Incluso puede ser desalentador trabajar en un nuevo proyecto y pensar en cómo mantener las cosas rápidas. Para las aplicaciones empresariales, al menos, hemos descubierto que el cuello de botella habitual son las pruebas, particularmente las pruebas que involucran servicios externos como una base de datos.

Probablemente el paso más crucial es comenzar a trabajar en la configuración de un Pipeline de Despliegue. La idea detrás de un pipeline de despliegue (también conocido como pipeline de construcción o construcción por etapas) es que, de hecho, se realizan múltiples construcciones en secuencia. El "commit" a la línea principal activa la primera construcción, lo que yo llamo la construcción de "commit". La construcción de "commit" es la construcción que se necesita cuando alguien envía "commits" a la línea principal. La construcción de "commit" es la que debe hacerse rápidamente, por lo que tomará una serie de atajos que reducirán la capacidad de detectar errores. El truco consiste en equilibrar las necesidades de detección de errores y velocidad para que una buena construcción de "commit" sea lo suficientemente estable para que otras personas puedan trabajar en ella.

Una vez que la construcción de "commit" es buena, otras personas pueden trabajar en el código con confianza. Sin embargo, hay más pruebas, más lentas, que podemos comenzar a hacer. Máquinas adicionales pueden ejecutar más rutinas de prueba en la construcción que tardan más en realizarse.

Un ejemplo simple de esto es un pipeline de despliegue de dos etapas. La primera etapa haría la compilación y ejecutaría pruebas que son pruebas unitarias más localizadas con servicios lentos reemplazados por Test Doubles, como una base de datos falsa en memoria o un "stub" para un servicio externo. Dichas pruebas pueden ejecutarse muy rápido, manteniéndose dentro de la guía de los diez minutos. Sin embargo, no se encontrarán errores que involucren interacciones a mayor escala, particularmente aquellas que involucran la base de datos real. La segunda etapa de la construcción ejecuta una suite de pruebas diferente que sí accede a una base de datos real e implica un comportamiento más de extremo a extremo. Esta suite podría tardar un par de horas en ejecutarse.

En este escenario, las personas usan la primera etapa como la construcción de "commit" y la utilizan como su ciclo principal de CI. Si la construcción secundaria falla, esto puede no tener la misma calidad de "detener todo", pero el equipo sí tiene como objetivo solucionar esos errores lo más rápido posible, mientras mantiene la construcción de "commit" en funcionamiento. Dado que la construcción secundaria puede ser mucho más lenta, es posible que no se ejecute después de cada "commit". En ese caso, se ejecuta con la mayor frecuencia posible, seleccionando la última construcción buena de la etapa de "commit".

Si la construcción secundaria detecta un error, es una señal de que la construcción de "commit" podría necesitar otra prueba. En la medida de lo posible, queremos asegurarnos de que cualquier falla en una etapa posterior conduzca a nuevas pruebas en la construcción de "commit" que hubieran detectado el error, para que el error permanezca corregido en la construcción de "commit". De esta manera, las pruebas de "commit" se fortalecen cada vez que algo las pasa. Hay casos en los que no hay forma de construir una prueba de ejecución rápida que exponga el error, por lo que podemos decidir probar esa condición solo en la construcción secundaria. La mayoría de las veces, afortunadamente, podemos añadir pruebas adecuadas a la construcción de "commit".

Otra forma de acelerar las cosas es usar paralelismo y múltiples máquinas. Los entornos en la nube, en particular, permiten a los equipos lanzar fácilmente una pequeña flota de servidores para las construcciones. Siempre que las pruebas puedan ejecutarse de forma razonablemente independiente, lo que las pruebas bien escritas pueden hacer, el uso de dicha flota puede lograr tiempos de construcción muy rápidos. Dichas construcciones paralelas en la nube también pueden ser útiles para la construcción previa a la integración de un desarrollador.

Mientras consideramos el proceso de construcción más amplio, vale la pena mencionar otra categoría de automatización: la interacción con las dependencias. La mayoría del software utiliza una amplia gama de software dependiente producido por diferentes organizaciones. Los cambios en estas dependencias pueden causar fallas en el producto. Por lo tanto, un equipo debe verificar automáticamente las nuevas versiones de las dependencias e integrarlas en la construcción, esencialmente como si fueran otro miembro del equipo. Esto debe hacerse con frecuencia, generalmente al menos diariamente, dependiendo de la tasa de cambio de las dependencias. Se debe utilizar un enfoque similar con la ejecución de pruebas de contrato (Contract Tests). Si estas interacciones de dependencia se vuelven rojas, no tienen el mismo efecto de "detener la línea" que las fallas de construcción regulares, pero requieren una acción rápida por parte del equipo para investigar y solucionar.

---

## Ocultar el trabajo en curso

La Integración Continua significa integrar tan pronto como haya un pequeño progreso y la construcción sea saludable. Frecuentemente, esto sugiere integrar antes de que una característica visible para el usuario esté completamente formada y lista para su lanzamiento. Por lo tanto, necesitamos considerar cómo manejar el **código latente**: código que forma parte de una característica sin terminar pero que está presente en una versión en vivo.

A algunas personas les preocupa el código latente porque implica incluir código que no tiene calidad de producción en el ejecutable lanzado. Los equipos que practican la Integración Continua se aseguran de que todo el código enviado a la línea principal sea de **calidad de producción**, junto con las pruebas que lo verifican. El código latente puede que nunca se ejecute en producción, pero eso no impide que se pruebe.

Podemos evitar que el código se ejecute en producción utilizando una **Interfaz Clave ("Keystone Interface")**, asegurando que la interfaz que proporciona un camino a la nueva característica sea lo último que añadimos a la base de código. Las pruebas aún pueden verificar el código en todos los niveles, excepto en esa interfaz final. En un sistema bien diseñado, dichos elementos de interfaz deben ser mínimos y, por lo tanto, fáciles de añadir con un breve episodio de programación.

Utilizando el **Lanzamiento Oscuro ("Dark Launching")** podemos probar algunos cambios en producción antes de hacerlos visibles para el usuario. Esta técnica es útil para evaluar el impacto en el rendimiento.

Las Interfaces Clave cubren la mayoría de los casos de código latente, pero para las ocasiones en que eso no es posible, utilizamos **Banderas de Características ("Feature Flags")**. Las banderas de características se verifican cada vez que estamos a punto de ejecutar código latente; se configuran como parte del entorno, quizás en un archivo de configuración específico del entorno. De esa manera, el código latente puede estar activo para pruebas, pero deshabilitado en producción. Además de habilitar la Integración Continua, las banderas de características también facilitan el cambio en tiempo de ejecución para **pruebas A/B y Lanzamientos Canary**. Luego nos aseguramos de eliminar esta lógica rápidamente una vez que una característica se lanza por completo, para que las banderas no desordenen la base de código.

La **Ramificación por Abstracción ("Branch By Abstraction")** es otra técnica para gestionar el código latente, que es particularmente útil para grandes cambios infraestructurales dentro de una base de código. Esencialmente, esto crea una interfaz interna para los módulos que se están cambiando. La interfaz puede entonces enrutar entre la lógica antigua y la nueva, reemplazando gradualmente las rutas de ejecución con el tiempo. Hemos visto esto para cambiar elementos tan omnipresentes como la plataforma de persistencia.

Al introducir una nueva característica, siempre debemos asegurarnos de que podemos **revertir** en caso de problemas. El **Cambio Paralelo ("Parallel Change", también conocido como "expandir-contraer")** divide un cambio en pasos reversibles. Por ejemplo, si renombramos un campo de la base de datos, primero creamos un nuevo campo con el nuevo nombre, luego escribimos en los campos antiguo y nuevo, luego copiamos datos de los campos antiguos existentes, luego leemos del nuevo campo y solo entonces eliminamos el campo antiguo. Podemos revertir cualquiera de estos pasos, lo que no sería posible si hiciéramos un cambio así de una sola vez. Los equipos que utilizan Integración Continua a menudo buscan dividir los cambios de esta manera, manteniéndolos pequeños y fáciles de deshacer.


## Probar en un clon del entorno de producción

El objetivo de las pruebas es detectar, bajo condiciones controladas, cualquier problema que el sistema pueda tener en producción. Una parte significativa de esto es el **entorno** en el cual se ejecutará el sistema de producción. Si probamos en un entorno diferente, cada diferencia resulta en un riesgo de que lo que sucede en las pruebas no suceda en producción.

En consecuencia, queremos configurar nuestro **entorno de prueba para que sea una imitación lo más exacta posible de nuestro entorno de producción**. Utilice el mismo software de base de datos, con las mismas versiones; utilice la misma versión del sistema operativo. Ponga todas las bibliotecas apropiadas que están en el entorno de producción en el entorno de prueba, incluso si el sistema no las utiliza realmente. Utilice las mismas direcciones IP y puertos; ejecútelo en el mismo hardware.

Los **entornos virtuales** facilitan mucho esto en comparación con el pasado. Ejecutamos el software de producción en contenedores y construimos de manera fiable exactamente los mismos contenedores para las pruebas, incluso en el espacio de trabajo de un desarrollador. Vale la pena el esfuerzo y el costo de hacer esto; el precio suele ser pequeño en comparación con la búsqueda de un solo error que surgió del agujero creado por las **discrepancias ambientales**.

Algunos software están diseñados para ejecutarse en múltiples entornos, como diferentes sistemas operativos y versiones de plataforma. El pipeline de despliegue debe organizar las pruebas en todos estos entornos en paralelo.

Un punto a tener en cuenta es cuando el entorno de producción no es tan bueno como el entorno de desarrollo. ¿El software de producción se ejecutará en máquinas conectadas con Wi-Fi deficiente, como los teléfonos inteligentes? Entonces, asegúrese de que un entorno de prueba **imite las malas conexiones de red**.

---

## Todo el mundo puede ver lo que está pasando

La Integración Continua se trata de **comunicación**, por lo que queremos asegurarnos de que todos puedan ver fácilmente el estado del sistema y los cambios que se le han realizado.

Una de las cosas más importantes a comunicar es el **estado de la construcción de la línea principal**. Los Servicios de CI tienen **paneles de control** que permiten a todos ver el estado de cualquier construcción que estén ejecutando. A menudo se enlazan con otras herramientas para difundir información de la construcción a herramientas internas de redes sociales como Slack. Los IDEs a menudo tienen conexiones a estos mecanismos, de modo que los desarrolladores pueden ser alertados mientras aún están dentro de la herramienta que utilizan para gran parte de su trabajo. Muchos equipos solo envían notificaciones de fallos de construcción, pero creo que vale la pena enviar mensajes también cuando hay éxito. De esa manera, la gente se acostumbra a las señales regulares y se hace una idea de la duración de la construcción. Sin mencionar el hecho de que es agradable recibir un "bien hecho" todos los días, incluso si es solo de un servidor de CI.

Los equipos que comparten un espacio físico a menudo tienen algún tipo de **pantalla física siempre encendida** para la construcción. Por lo general, esto toma la forma de una pantalla grande que muestra un panel de control simplificado. Esto es particularmente valioso para alertar a todos sobre una construcción fallida, a menudo utilizando los colores **rojo/verde** en la construcción de "commit" de la línea principal.

Una de las pantallas físicas más antiguas que me gustaba bastante era el uso de **lámparas de lava rojas y verdes**. Una de las características de una lámpara de lava es que, después de estar encendidas un tiempo, comienzan a burbujear. La idea era que si la lámpara roja se encendía, el equipo debía arreglar la construcción antes de que comenzara a burbujear. Las pantallas físicas para el estado de la construcción a menudo se volvían lúdicas, añadiendo una personalidad peculiar al espacio de trabajo de un equipo. Tengo gratos recuerdos de un conejo bailarín.

Además del estado actual de la construcción, estas pantallas pueden mostrar información útil sobre el **historial reciente**, lo que puede ser un indicador de la salud del proyecto. A principios de siglo trabajé con un equipo que tenía un historial de no poder crear construcciones estables. Pusimos un calendario en la pared que mostraba un año completo con un pequeño cuadrado para cada día. Cada día, el grupo de QA ponía una pegatina verde en el día si habían recibido una construcción estable que pasaba las pruebas de "commit", de lo contrario, un cuadrado rojo. Con el tiempo, el calendario reveló el estado del proceso de construcción, mostrando una mejora constante hasta que los cuadrados verdes fueron tan comunes que el calendario desapareció, cumpliendo su propósito.

---